<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Confluence TypeScript Client&#10;&#10;A modern TypeScript client for interacting with Atlassian Confluence's REST API. This library provides a convenient way to access Confluence pages, spaces, and other content programmatically.&#10;&#10;## Features&#10;&#10;-  Complete TypeScript support with proper type definitions&#10;-  Simple page retrieval and searching&#10;- ️ Content categorization with labels&#10;-  Advanced search capabilities&#10;-  Attachment handling&#10;-  AI-ready with MCP (Model Context Protocol) integration&#10;&#10;## Installation&#10;&#10;```bash&#10;npm install confluence-ts-client&#10;```&#10;&#10;## Basic Usage&#10;&#10;```typescript&#10;import { ConfluenceClient } from 'confluence-ts-client';&#10;&#10;// Initialize the client&#10;const client = new ConfluenceClient(&#10;  'your-domain.atlassian.net',&#10;  'your-email@example.com',&#10;  'your-api-token'&#10;);&#10;&#10;// Get a page by ID&#10;const page = await client.getPageById('123456789');&#10;console.log(`Page title: ${page.title}`);&#10;console.log(`Page content: ${page.body.storage.value}`);&#10;&#10;// Search for pages by title&#10;const searchResults = await client.getPagesByTitle('Meeting Notes');&#10;console.log(`Found ${searchResults.results.length} pages`);&#10;```&#10;&#10;## Environment Variables&#10;&#10;You can also configure the client using environment variables:&#10;&#10;```typescript&#10;import { ConfluenceClient } from 'confluence-ts-client';&#10;import dotenv from 'dotenv';&#10;&#10;dotenv.config();&#10;&#10;const client = new ConfluenceClient(&#10;  process.env.CONFLUENCE_DOMAIN,&#10;  process.env.CONFLUENCE_USER,&#10;  process.env.CONFLUENCE_TOKEN&#10;);&#10;```&#10;&#10;## API Reference&#10;&#10;### Core Methods&#10;&#10;#### `getPageById(pageId: string, expand?: string[]): Promise&lt;ConfluencePage&gt;`&#10;Get a Confluence page by its ID.&#10;&#10;#### `search(cql: string): Promise&lt;ConfluencePageListResponse&gt;`&#10;Search for content using Confluence Query Language (CQL).&#10;&#10;#### `getPagesByTitle(title: string, spaceKey?: string, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;Find pages with titles containing the search term.&#10;&#10;#### `getPagesBySpaceKey(spaceKey: string, limit?: number, start?: number, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;List all pages within a specific space.&#10;&#10;#### `getPageChildren(pageId: string, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;Get all child pages of a specific page.&#10;&#10;### Space Methods&#10;&#10;#### `getSpaces(type?: 'global' | 'personal', status?: 'current' | 'archived', limit?: number, start?: number): Promise&lt;ConfluenceSpaceListResponse&gt;`&#10;List all spaces the user has access to.&#10;&#10;### Content Organization&#10;&#10;#### `getContentByLabel(labelName: string, spaceKey?: string, limit?: number, start?: number): Promise&lt;ConfluencePageListResponse&gt;`&#10;Find content with a specific label.&#10;&#10;#### `getContentLabels(contentId: string, prefix?: string, limit?: number, start?: number): Promise&lt;any&gt;`&#10;Get all labels for a specific content item.&#10;&#10;### Comments &amp; Attachments&#10;&#10;#### `getPageComments(pageId: string, limit?: number, start?: number, expand?: string[]): Promise&lt;ConfluenceCommentListResponse&gt;`&#10;Get comments for a page.&#10;&#10;#### `getAttachments(pageId: string, filename?: string, mediaType?: string, limit?: number, start?: number, expand?: string[]): Promise&lt;ConfluenceAttachmentListResponse&gt;`&#10;Get attachments for a page.&#10;&#10;#### `getAttachment(attachmentId: string): Promise&lt;ConfluenceAttachment&gt;`&#10;Get a specific attachment by ID.&#10;&#10;#### `downloadAttachment(attachmentId: string): Promise&lt;{data: ArrayBuffer, contentType: string, filename: string}&gt;`&#10;Download the binary content of an attachment.&#10;&#10;### Related Content&#10;&#10;#### `getTopicallyRelatedPages(pageId: string, limit?: number, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;Find pages that are topically related to a given page based on title similarity and shared labels.&#10;&#10;#### `getRecentlyUpdated(spaceKey?: string, type?: 'page' | 'blogpost' | 'comment' | 'attachment', limit?: number, start?: number, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;Get recently updated content.&#10;&#10;#### `getPageHistory(pageId: string, limit?: number, start?: number): Promise&lt;any&gt;`&#10;Get the version history of a page.&#10;&#10;## MCP Integration&#10;&#10;This library includes a ready-to-use Model Context Protocol (MCP) server that makes all Confluence API capabilities available to AI models like Anthropic's Claude.&#10;&#10;### Starting the MCP Server&#10;&#10;```bash&#10;# Install dependencies&#10;npm install fastmcp zod&#10;&#10;# Create a .env file with your Confluence credentials&#10;echo &quot;CONFLUENCE_DOMAIN=your-domain.atlassian.net&#10;CONFLUENCE_USER=your-email@example.com&#10;CONFLUENCE_TOKEN=your-api-token&quot; &gt; .env&#10;&#10;# Start the server&#10;npx ts-node --esm src/index.ts&#10;```&#10;&#10;### Available MCP Tools&#10;&#10;- `getPageById`: Get a Confluence page by its ID&#10;- `searchPagesByTitle`: Search for pages by title&#10;- `getPagesInSpace`: Get all pages in a specific space&#10;- `getChildPages`: Get child pages of a page&#10;- `getAllSpaces`: Get all accessible spaces&#10;- `getPageHistory`: Get page history versions&#10;- `getPageComments`: Get page comments&#10;- `getPageAttachments`: Get page attachments&#10;- `getRelatedPages`: Find topically related pages&#10;- `getRecentlyUpdated`: Get recently updated content&#10;- `getContentByLabel`: Get content by label&#10;&#10;## Error Handling&#10;&#10;The client includes comprehensive error handling with detailed error messages for common issues like authentication failures or missing resources.&#10;&#10;## Types&#10;&#10;All response types are fully documented with TypeScript interfaces for excellent IDE integration and type safety.&#10;&#10;## License&#10;&#10;MIT&#10;&#10;## Supported Tools&#10;&#10;### Confluence Tools&#10;- **Get page by ID**: Retrieve a Confluence page by its ID.&#10;- **Search pages by title**: Search for Confluence pages by title (optionally within a space).&#10;- **Get page comments**: Retrieve comments on a Confluence page.&#10;- **Get page attachments**: Retrieve attachments on a Confluence page (with optional filters).&#10;- **Get topically related pages**: Find pages that are topically related to a given page.&#10;&#10;### Jira Tools&#10;- **Get Jira issue by key**: Retrieve a Jira issue by its key (e.g., PROJECT-123).&#10;- **Get all issues in a sprint**: Retrieve all issues in a sprint, optionally filtered by issue types.&#10;- **Get related issues**: Find related issues for a given Jira issue.&#10;- **Get all issues in the active sprint for a board**: Retrieve all issues in the current active sprint for a given Jira board.&#10;&#10;---&#10;&#10;For usage details and environment setup, see the code and comments in `src/index.ts`.&#10;" />
              <option name="updatedContent" value="# Confluence TypeScript Client&#10;&#10;A modern TypeScript client for interacting with Atlassian Confluence's REST API. This library provides a convenient way to access Confluence pages, spaces, and other content programmatically.&#10;&#10;## Features&#10;&#10;-  Complete TypeScript support with proper type definitions&#10;-  Simple page retrieval and searching&#10;- ️ Content categorization with labels&#10;-  Advanced search capabilities&#10;-  Attachment handling&#10;-  AI-ready with MCP (Model Context Protocol) integration&#10;&#10;## Installation&#10;&#10;```bash&#10;npm install confluence-ts-client&#10;```&#10;&#10;## Basic Usage&#10;&#10;```typescript&#10;import { ConfluenceClient } from 'confluence-ts-client';&#10;&#10;// Initialize the client&#10;const client = new ConfluenceClient(&#10;  'your-domain.atlassian.net',&#10;  'your-email@example.com',&#10;  'your-api-token'&#10;);&#10;&#10;// Get a page by ID&#10;const page = await client.getPageById('123456789');&#10;console.log(`Page title: ${page.title}`);&#10;console.log(`Page content: ${page.body.storage.value}`);&#10;&#10;// Search for pages by title&#10;const searchResults = await client.getPagesByTitle('Meeting Notes');&#10;console.log(`Found ${searchResults.results.length} pages`);&#10;```&#10;&#10;## Environment Variables&#10;&#10;You can also configure the client using environment variables:&#10;&#10;```typescript&#10;import { ConfluenceClient } from 'confluence-ts-client';&#10;import dotenv from 'dotenv';&#10;&#10;dotenv.config();&#10;&#10;const client = new ConfluenceClient(&#10;  process.env.CONFLUENCE_DOMAIN,&#10;  process.env.CONFLUENCE_USER,&#10;  process.env.CONFLUENCE_TOKEN&#10;);&#10;```&#10;&#10;## API Reference&#10;&#10;### Core Methods&#10;&#10;#### `getPageById(pageId: string, expand?: string[]): Promise&lt;ConfluencePage&gt;`&#10;Get a Confluence page by its ID.&#10;&#10;#### `search(cql: string): Promise&lt;ConfluencePageListResponse&gt;`&#10;Search for content using Confluence Query Language (CQL).&#10;&#10;#### `getPagesByTitle(title: string, spaceKey?: string, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;Find pages with titles containing the search term.&#10;&#10;#### `getPagesBySpaceKey(spaceKey: string, limit?: number, start?: number, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;List all pages within a specific space.&#10;&#10;#### `getPageChildren(pageId: string, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;Get all child pages of a specific page.&#10;&#10;### Space Methods&#10;&#10;#### `getSpaces(type?: 'global' | 'personal', status?: 'current' | 'archived', limit?: number, start?: number): Promise&lt;ConfluenceSpaceListResponse&gt;`&#10;List all spaces the user has access to.&#10;&#10;### Content Organization&#10;&#10;#### `getContentByLabel(labelName: string, spaceKey?: string, limit?: number, start?: number): Promise&lt;ConfluencePageListResponse&gt;`&#10;Find content with a specific label.&#10;&#10;#### `getContentLabels(contentId: string, prefix?: string, limit?: number, start?: number): Promise&lt;any&gt;`&#10;Get all labels for a specific content item.&#10;&#10;### Comments &amp; Attachments&#10;&#10;#### `getPageComments(pageId: string, limit?: number, start?: number, expand?: string[]): Promise&lt;ConfluenceCommentListResponse&gt;`&#10;Get comments for a page.&#10;&#10;#### `getAttachments(pageId: string, filename?: string, mediaType?: string, limit?: number, start?: number, expand?: string[]): Promise&lt;ConfluenceAttachmentListResponse&gt;`&#10;Get attachments for a page.&#10;&#10;#### `getAttachment(attachmentId: string): Promise&lt;ConfluenceAttachment&gt;`&#10;Get a specific attachment by ID.&#10;&#10;#### `downloadAttachment(attachmentId: string): Promise&lt;{data: ArrayBuffer, contentType: string, filename: string}&gt;`&#10;Download the binary content of an attachment.&#10;&#10;### Related Content&#10;&#10;#### `getTopicallyRelatedPages(pageId: string, limit?: number, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;Find pages that are topically related to a given page based on title similarity and shared labels.&#10;&#10;#### `getRecentlyUpdated(spaceKey?: string, type?: 'page' | 'blogpost' | 'comment' | 'attachment', limit?: number, start?: number, expand?: string[]): Promise&lt;ConfluencePageListResponse&gt;`&#10;Get recently updated content.&#10;&#10;#### `getPageHistory(pageId: string, limit?: number, start?: number): Promise&lt;any&gt;`&#10;Get the version history of a page.&#10;&#10;## MCP Integration&#10;&#10;This library includes a ready-to-use Model Context Protocol (MCP) server that makes all Confluence API capabilities available to AI models like Anthropic's Claude.&#10;&#10;### Starting the MCP Server&#10;&#10;```bash&#10;# Install dependencies&#10;npm install fastmcp zod&#10;&#10;# Create a .env file with your Confluence credentials&#10;echo &quot;CONFLUENCE_DOMAIN=your-domain.atlassian.net&#10;CONFLUENCE_USER=your-email@example.com&#10;CONFLUENCE_TOKEN=your-api-token&quot; &gt; .env&#10;&#10;# Start the server&#10;npx ts-node --esm src/index.ts&#10;```&#10;&#10;### Available MCP Tools&#10;&#10;#### Confluence Tools&#10;- `getPageById`: Get a Confluence page by its ID&#10;- `searchPagesByTitle`: Search for Confluence pages by title (optionally within a space)&#10;- `getPageComments`: Get comments on a Confluence page&#10;- `getPageAttachments`: Get attachments on a Confluence page (with optional filters)&#10;- `getRelatedPages`: Find pages that are topically related to a given page&#10;&#10;#### Jira Tools&#10;- `getJiraIssue`: Get a Jira issue by its key (e.g., PROJECT-123)&#10;- `getSprintIssues`: Get all issues in a sprint, optionally filtered by issue types&#10;- `getRelatedIssues`: Find related issues for a given Jira issue&#10;- `getActiveSprintIssues`: Get all issues in the current active sprint for a given Jira board&#10;&#10;## Error Handling&#10;&#10;The client includes comprehensive error handling with detailed error messages for common issues like authentication failures or missing resources.&#10;&#10;## Types&#10;&#10;All response types are fully documented with TypeScript interfaces for excellent IDE integration and type safety.&#10;&#10;## License&#10;&#10;MIT&#10;&#10;## Supported Tools&#10;&#10;### Confluence Tools&#10;- **Get page by ID**: Retrieve a Confluence page by its ID.&#10;- **Search pages by title**: Search for Confluence pages by title (optionally within a space).&#10;- **Get page comments**: Retrieve comments on a Confluence page.&#10;- **Get page attachments**: Retrieve attachments on a Confluence page (with optional filters).&#10;- **Get topically related pages**: Find pages that are topically related to a given page.&#10;&#10;### Jira Tools&#10;- **Get Jira issue by key**: Retrieve a Jira issue by its key (e.g., PROJECT-123).&#10;- **Get all issues in a sprint**: Retrieve all issues in a sprint, optionally filtered by issue types.&#10;- **Get related issues**: Find related issues for a given Jira issue.&#10;- **Get all issues in the active sprint for a board**: Retrieve all issues in the current active sprint for a given Jira board.&#10;&#10;---&#10;&#10;For usage details and environment setup, see the code and comments in `src/index.ts`." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="originalContent" value="#!/usr/bin/env node&#10;&#10;import { FastMCP, UserError } from 'fastmcp';&#10;import { z } from 'zod';&#10;import { ConfluenceClient } from './confluence/ConfluenceClient.js';&#10;import { SimplePageResult } from './confluence/confluenceTypes.js';&#10;import { JiraClient } from './jira/JiraClient.js';&#10;import 'dotenv/config';&#10;&#10;// Initialize clients&#10;let client: ConfluenceClient;&#10;let jiraClient: JiraClient;&#10;&#10;export enum AtlassianServiceType {&#10;  Confluence = 'confluence',&#10;  Jira = 'jira',&#10;}&#10;&#10;function initAtlassianClient&lt;T extends AtlassianServiceType&gt;(&#10;  type: T&#10;): T extends AtlassianServiceType.Confluence ? ConfluenceClient : JiraClient {&#10;  const { ATLASSIAN_DOMAIN, ATLASSIAN_USER, ATLASSIAN_TOKEN } = process.env;&#10;  if (!ATLASSIAN_DOMAIN || !ATLASSIAN_USER || !ATLASSIAN_TOKEN) {&#10;    throw new UserError(&#10;      'Please set ATLASSIAN_DOMAIN, ATLASSIAN_USER, and ATLASSIAN_TOKEN in the .env file'&#10;    );&#10;  }&#10;  if (type === AtlassianServiceType.Confluence) {&#10;    return new ConfluenceClient(&#10;      ATLASSIAN_DOMAIN,&#10;      ATLASSIAN_USER,&#10;      ATLASSIAN_TOKEN&#10;    ) as any;&#10;  } else {&#10;    return new JiraClient(&#10;      ATLASSIAN_DOMAIN,&#10;      ATLASSIAN_USER,&#10;      ATLASSIAN_TOKEN&#10;    ) as any;&#10;  }&#10;}&#10;&#10;// Create FastMCP server&#10;const server = new FastMCP({&#10;  name: 'ConfluenceAssistant',&#10;  version: '1.0.0',&#10;  instructions: `This is a Confluence Assistant providing the following functions:&#10;  - Get page by ID&#10;  - Search pages by title&#10;  - Get all pages in a specific space&#10;  - Get child pages of a page&#10;  - Get all accessible spaces&#10;  - Get page history versions&#10;  - Get page comments&#10;  - Get page attachments&#10;  - Download specific attachments&#10;  - Get recently updated content&#10;  - Get content by label`,&#10;});&#10;&#10;// Error handling function&#10;const handleError = (error: any): never =&gt; {&#10;  if (error.response) {&#10;    const status = error.response.status;&#10;    const statusText = error.response.statusText;&#10;&#10;    if (status === 401) {&#10;      throw new UserError(&#10;        'Authentication Error: Failed to authenticate with Confluence. Please check your credentials.'&#10;      );&#10;    } else if (status === 403) {&#10;      throw new UserError(&#10;        'Permission Error: You do not have permission to access this resource in Confluence.'&#10;      );&#10;    } else if (status === 404) {&#10;      throw new UserError(&#10;        'Not Found Error: The requested Confluence resource could not be found. Please check the provided ID or parameters.'&#10;      );&#10;    } else {&#10;      throw new UserError(`Confluence API Error: ${status} ${statusText}`);&#10;    }&#10;  } else if (error instanceof UserError) {&#10;    // Pass through UserError instances&#10;    throw error;&#10;  } else {&#10;    throw new UserError(`An unexpected error occurred: ${error.message}`);&#10;  }&#10;};&#10;&#10;// Add MCP tool: Get Confluence page by ID&#10;server.addTool({&#10;  name: 'getPageById',&#10;  description: 'Get a Confluence page by its ID',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the Confluence page'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const page = await client.getPageById(args.pageId, ['body.storage']);&#10;&#10;      // Create a simplified page result with only the requested fields&#10;      const simpleResult: SimplePageResult = {&#10;        id: page.id,&#10;        status: page.status,&#10;        title: page.title,&#10;        content: page.body?.storage?.value || '',&#10;      };&#10;&#10;      return JSON.stringify(simpleResult, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Search pages by title&#10;server.addTool({&#10;  name: 'searchPagesByTitle',&#10;  description: 'Search for Confluence pages by title',&#10;  parameters: z.object({&#10;    title: z.string().describe('Page title or title fragment'),&#10;    spaceKey: z&#10;      .string()&#10;      .optional()&#10;      .describe('Optional space key to limit search scope'),&#10;    expand: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&quot;Fields to expand, e.g. ['body.storage']&quot;),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const pages = await client.getPagesByTitle(&#10;        args.title,&#10;        args.spaceKey,&#10;        args.expand || ['body.storage']&#10;      );&#10;      return JSON.stringify(pages, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get page comments&#10;server.addTool({&#10;  name: 'getPageComments',&#10;  description: 'Get comments on a Confluence page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the page'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 25'),&#10;    start: z&#10;      .number()&#10;      .optional()&#10;      .describe('Starting index for pagination, default is 0'),&#10;    expand: z.array(z.string()).optional().describe('Fields to expand'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const comments = await client.getPageComments(&#10;        args.pageId,&#10;        args.limit,&#10;        args.start,&#10;        args.expand || []&#10;      );&#10;      return JSON.stringify(comments, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get page attachments&#10;server.addTool({&#10;  name: 'getPageAttachments',&#10;  description: 'Get attachments on a Confluence page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the page'),&#10;    filename: z.string().optional().describe('Optional filename filter'),&#10;    mediaType: z.string().optional().describe('Optional media type filter'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 25'),&#10;    start: z&#10;      .number()&#10;      .optional()&#10;      .describe('Starting index for pagination, default is 0'),&#10;    expand: z.array(z.string()).optional().describe('Fields to expand'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const attachments = await client.getAttachments(&#10;        args.pageId,&#10;        args.filename,&#10;        args.mediaType,&#10;        args.limit,&#10;        args.start,&#10;        args.expand || []&#10;      );&#10;      return JSON.stringify(attachments, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get topically related pages&#10;server.addTool({&#10;  name: 'getRelatedPages',&#10;  description: 'Find pages that are topically related to a given page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the reference page'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 10'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const pagesResponse = await client.getTopicallyRelatedPages(&#10;        args.pageId,&#10;        args.limit || 10,&#10;        ['body.storage']&#10;      );&#10;&#10;      // Transform the results to SimplePageResult format&#10;      const simpleResults = pagesResponse.results.map(page =&gt; ({&#10;        id: page.id,&#10;        status: page.status,&#10;        title: page.title,&#10;        content: page.body?.storage?.value || '',&#10;      }));&#10;&#10;      // Return in the format expected by FastMCP&#10;      return JSON.stringify(&#10;        {&#10;          content: simpleResults,&#10;          totalCount: pagesResponse.size,&#10;          relatedToPageId: args.pageId,&#10;        },&#10;        null,&#10;        2&#10;      );&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get Jira issue by key&#10;server.addTool({&#10;  name: 'getJiraIssue',&#10;  description: 'Get a Jira issue by its key',&#10;  parameters: z.object({&#10;    issueKey: z&#10;      .string()&#10;      .describe('The key of the Jira issue (e.g., PROJECT-123)'),&#10;    fields: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe('Optional array of field names to include'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const issue = await jiraClient.getIssue(args.issueKey, args.fields);&#10;      // Only return extractedDetails (use type assertion to avoid TS error)&#10;      const extractedDetails = (issue as any).extractedDetails;&#10;      return typeof extractedDetails === 'string'&#10;        ? extractedDetails&#10;        : JSON.stringify(extractedDetails, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get all issues in a sprint, optionally filtered by a list of issue types&#10;server.addTool({&#10;  name: 'getSprintIssues',&#10;  description:&#10;    'Get all issues in a sprint, optionally filtered by a list of issue types',&#10;  parameters: z.object({&#10;    sprintId: z.number().describe('The ID of the sprint'),&#10;    startAt: z.number().optional().describe('Starting index for pagination'),&#10;    maxResults: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return'),&#10;    issueTypes: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&#10;        'Optional array of issue types to filter (e.g., [&quot;Story&quot;, &quot;Bug&quot;])'&#10;      ),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const issues = await jiraClient.getSprintIssues(&#10;        args.sprintId,&#10;        args.startAt || 0,&#10;        args.maxResults || 50,&#10;        args.issueTypes&#10;      );&#10;      return JSON.stringify(issues, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get related issues for a given issue&#10;server.addTool({&#10;  name: 'getRelatedIssues',&#10;  description: 'Find related issues for a given Jira issue',&#10;  parameters: z.object({&#10;    issueKey: z&#10;      .string()&#10;      .describe('The key of the Jira issue to find related issues for'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const related = await jiraClient.getRelatedIssues(args.issueKey);&#10;      return JSON.stringify(related, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get all issues in the active sprint for a board&#10;server.addTool({&#10;  name: 'getActiveSprintIssues',&#10;  description:&#10;    'Get all issues in the current active sprint for a given Jira board',&#10;  parameters: z.object({&#10;    boardId: z.number().describe('The ID of the Jira board'),&#10;    issueTypes: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&#10;        'Optional array of issue types to filter (e.g., [&quot;Story&quot;, &quot;Bug&quot;])'&#10;      ),&#10;    startAt: z.number().optional().describe('Starting index for pagination'),&#10;    maxResults: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      // Get the active sprint for the board&#10;      const sprintsResp = await jiraClient.getSprints(&#10;        args.boardId,&#10;        'active',&#10;        0,&#10;        1&#10;      );&#10;      const activeSprint =&#10;        sprintsResp.values &amp;&amp; sprintsResp.values.length &gt; 0&#10;          ? sprintsResp.values[0]&#10;          : null;&#10;      if (!activeSprint) {&#10;        return JSON.stringify(&#10;          { error: 'No active sprint found for this board.' },&#10;          null,&#10;          2&#10;        );&#10;      }&#10;      // Use default issueTypes if not provided&#10;      const issueTypes =&#10;        args.issueTypes &amp;&amp; args.issueTypes.length &gt; 0&#10;          ? args.issueTypes&#10;          : ['Story', 'Bug'];&#10;      // Get issues in the active sprint&#10;      const issues = await jiraClient.getSprintIssues(&#10;        activeSprint.id,&#10;        args.startAt || 0,&#10;        args.maxResults || 50,&#10;        issueTypes&#10;      );&#10;      return JSON.stringify({ sprint: activeSprint, issues }, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;await server.start({&#10;  transportType: 'stdio',&#10;});&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env node&#10;&#10;import { FastMCP, UserError } from 'fastmcp';&#10;import { z } from 'zod';&#10;import { ConfluenceClient } from './confluence/ConfluenceClient.js';&#10;import { SimplePageResult } from './confluence/confluenceTypes.js';&#10;import { JiraClient } from './jira/JiraClient.js';&#10;import 'dotenv/config';&#10;&#10;// Initialize clients&#10;let client: ConfluenceClient;&#10;let jiraClient: JiraClient;&#10;&#10;export enum AtlassianServiceType {&#10;  Confluence = 'confluence',&#10;  Jira = 'jira',&#10;}&#10;&#10;function initAtlassianClient&lt;T extends AtlassianServiceType&gt;(&#10;  type: T&#10;): T extends AtlassianServiceType.Confluence ? ConfluenceClient : JiraClient {&#10;  const { ATLASSIAN_DOMAIN, ATLASSIAN_USER, ATLASSIAN_TOKEN } = process.env;&#10;  if (!ATLASSIAN_DOMAIN || !ATLASSIAN_USER || !ATLASSIAN_TOKEN) {&#10;    throw new UserError(&#10;      'Please set ATLASSIAN_DOMAIN, ATLASSIAN_USER, and ATLASSIAN_TOKEN in the .env file'&#10;    );&#10;  }&#10;  if (type === AtlassianServiceType.Confluence) {&#10;    return new ConfluenceClient(&#10;      ATLASSIAN_DOMAIN,&#10;      ATLASSIAN_USER,&#10;      ATLASSIAN_TOKEN&#10;    ) as any;&#10;  } else {&#10;    return new JiraClient(&#10;      ATLASSIAN_DOMAIN,&#10;      ATLASSIAN_USER,&#10;      ATLASSIAN_TOKEN&#10;    ) as any;&#10;  }&#10;}&#10;&#10;// Create FastMCP server&#10;const server = new FastMCP({&#10;  name: 'ConfluenceAssistant',&#10;  version: '1.0.0',&#10;  instructions: `This assistant provides the following MCP tools for Atlassian Confluence and Jira:&#10;&#10;Confluence:&#10;- getPageById: Get a Confluence page by its ID&#10;- searchPagesByTitle: Search for Confluence pages by title (optionally within a space)&#10;- getPageComments: Get comments on a Confluence page&#10;- getPageAttachments: Get attachments on a Confluence page (with optional filters)&#10;- getRelatedPages: Find pages that are topically related to a given page&#10;&#10;Jira:&#10;- getJiraIssue: Get a Jira issue by its key (e.g., PROJECT-123)&#10;- getSprintIssues: Get all issues in a sprint, optionally filtered by issue types&#10;- getRelatedIssues: Find related issues for a given Jira issue&#10;- getActiveSprintIssues: Get all issues in the current active sprint for a given Jira board&#10;&#10;Refer to the README for parameter details.`,&#10;});&#10;&#10;// Error handling function&#10;const handleError = (error: any): never =&gt; {&#10;  if (error.response) {&#10;    const status = error.response.status;&#10;    const statusText = error.response.statusText;&#10;&#10;    if (status === 401) {&#10;      throw new UserError(&#10;        'Authentication Error: Failed to authenticate with Confluence. Please check your credentials.'&#10;      );&#10;    } else if (status === 403) {&#10;      throw new UserError(&#10;        'Permission Error: You do not have permission to access this resource in Confluence.'&#10;      );&#10;    } else if (status === 404) {&#10;      throw new UserError(&#10;        'Not Found Error: The requested Confluence resource could not be found. Please check the provided ID or parameters.'&#10;      );&#10;    } else {&#10;      throw new UserError(`Confluence API Error: ${status} ${statusText}`);&#10;    }&#10;  } else if (error instanceof UserError) {&#10;    // Pass through UserError instances&#10;    throw error;&#10;  } else {&#10;    throw new UserError(`An unexpected error occurred: ${error.message}`);&#10;  }&#10;};&#10;&#10;// Add MCP tool: Get Confluence page by ID&#10;server.addTool({&#10;  name: 'getPageById',&#10;  description: 'Get a Confluence page by its ID',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the Confluence page'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const page = await client.getPageById(args.pageId, ['body.storage']);&#10;&#10;      // Create a simplified page result with only the requested fields&#10;      const simpleResult: SimplePageResult = {&#10;        id: page.id,&#10;        status: page.status,&#10;        title: page.title,&#10;        content: page.body?.storage?.value || '',&#10;      };&#10;&#10;      return JSON.stringify(simpleResult, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Search pages by title&#10;server.addTool({&#10;  name: 'searchPagesByTitle',&#10;  description: 'Search for Confluence pages by title',&#10;  parameters: z.object({&#10;    title: z.string().describe('Page title or title fragment'),&#10;    spaceKey: z&#10;      .string()&#10;      .optional()&#10;      .describe('Optional space key to limit search scope'),&#10;    expand: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&quot;Fields to expand, e.g. ['body.storage']&quot;),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const pages = await client.getPagesByTitle(&#10;        args.title,&#10;        args.spaceKey,&#10;        args.expand || ['body.storage']&#10;      );&#10;      return JSON.stringify(pages, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get page comments&#10;server.addTool({&#10;  name: 'getPageComments',&#10;  description: 'Get comments on a Confluence page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the page'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 25'),&#10;    start: z&#10;      .number()&#10;      .optional()&#10;      .describe('Starting index for pagination, default is 0'),&#10;    expand: z.array(z.string()).optional().describe('Fields to expand'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const comments = await client.getPageComments(&#10;        args.pageId,&#10;        args.limit,&#10;        args.start,&#10;        args.expand || []&#10;      );&#10;      return JSON.stringify(comments, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get page attachments&#10;server.addTool({&#10;  name: 'getPageAttachments',&#10;  description: 'Get attachments on a Confluence page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the page'),&#10;    filename: z.string().optional().describe('Optional filename filter'),&#10;    mediaType: z.string().optional().describe('Optional media type filter'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 25'),&#10;    start: z&#10;      .number()&#10;      .optional()&#10;      .describe('Starting index for pagination, default is 0'),&#10;    expand: z.array(z.string()).optional().describe('Fields to expand'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const attachments = await client.getAttachments(&#10;        args.pageId,&#10;        args.filename,&#10;        args.mediaType,&#10;        args.limit,&#10;        args.start,&#10;        args.expand || []&#10;      );&#10;      return JSON.stringify(attachments, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get topically related pages&#10;server.addTool({&#10;  name: 'getRelatedPages',&#10;  description: 'Find pages that are topically related to a given page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the reference page'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 10'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const pagesResponse = await client.getTopicallyRelatedPages(&#10;        args.pageId,&#10;        args.limit || 10,&#10;        ['body.storage']&#10;      );&#10;&#10;      // Transform the results to SimplePageResult format&#10;      const simpleResults = pagesResponse.results.map(page =&gt; ({&#10;        id: page.id,&#10;        status: page.status,&#10;        title: page.title,&#10;        content: page.body?.storage?.value || '',&#10;      }));&#10;&#10;      // Return in the format expected by FastMCP&#10;      return JSON.stringify(&#10;        {&#10;          content: simpleResults,&#10;          totalCount: pagesResponse.size,&#10;          relatedToPageId: args.pageId,&#10;        },&#10;        null,&#10;        2&#10;      );&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get Jira issue by key&#10;server.addTool({&#10;  name: 'getJiraIssue',&#10;  description: 'Get a Jira issue by its key',&#10;  parameters: z.object({&#10;    issueKey: z&#10;      .string()&#10;      .describe('The key of the Jira issue (e.g., PROJECT-123)'),&#10;    fields: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe('Optional array of field names to include'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const issue = await jiraClient.getIssue(args.issueKey, args.fields);&#10;      // Only return extractedDetails (use type assertion to avoid TS error)&#10;      const extractedDetails = (issue as any).extractedDetails;&#10;      return typeof extractedDetails === 'string'&#10;        ? extractedDetails&#10;        : JSON.stringify(extractedDetails, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get all issues in a sprint, optionally filtered by a list of issue types&#10;server.addTool({&#10;  name: 'getSprintIssues',&#10;  description:&#10;    'Get all issues in a sprint, optionally filtered by a list of issue types',&#10;  parameters: z.object({&#10;    sprintId: z.number().describe('The ID of the sprint'),&#10;    startAt: z.number().optional().describe('Starting index for pagination'),&#10;    maxResults: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return'),&#10;    issueTypes: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&#10;        'Optional array of issue types to filter (e.g., [&quot;Story&quot;, &quot;Bug&quot;])'&#10;      ),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const issues = await jiraClient.getSprintIssues(&#10;        args.sprintId,&#10;        args.startAt || 0,&#10;        args.maxResults || 50,&#10;        args.issueTypes&#10;      );&#10;      return JSON.stringify(issues, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get related issues for a given issue&#10;server.addTool({&#10;  name: 'getRelatedIssues',&#10;  description: 'Find related issues for a given Jira issue',&#10;  parameters: z.object({&#10;    issueKey: z&#10;      .string()&#10;      .describe('The key of the Jira issue to find related issues for'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const related = await jiraClient.getRelatedIssues(args.issueKey);&#10;      return JSON.stringify(related, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get all issues in the active sprint for a board&#10;server.addTool({&#10;  name: 'getActiveSprintIssues',&#10;  description:&#10;    'Get all issues in the current active sprint for a given Jira board',&#10;  parameters: z.object({&#10;    boardId: z.number().describe('The ID of the Jira board'),&#10;    issueTypes: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&#10;        'Optional array of issue types to filter (e.g., [&quot;Story&quot;, &quot;Bug&quot;])'&#10;      ),&#10;    startAt: z.number().optional().describe('Starting index for pagination'),&#10;    maxResults: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      // Get the active sprint for the board&#10;      const sprintsResp = await jiraClient.getSprints(&#10;        args.boardId,&#10;        'active',&#10;        0,&#10;        1&#10;      );&#10;      const activeSprint =&#10;        sprintsResp.values &amp;&amp; sprintsResp.values.length &gt; 0&#10;          ? sprintsResp.values[0]&#10;          : null;&#10;      if (!activeSprint) {&#10;        return JSON.stringify(&#10;          { error: 'No active sprint found for this board.' },&#10;          null,&#10;          2&#10;        );&#10;      }&#10;      // Use default issueTypes if not provided&#10;      const issueTypes =&#10;        args.issueTypes &amp;&amp; args.issueTypes.length &gt; 0&#10;          ? args.issueTypes&#10;          : ['Story', 'Bug'];&#10;      // Get issues in the active sprint&#10;      const issues = await jiraClient.getSprintIssues(&#10;        activeSprint.id,&#10;        args.startAt || 0,&#10;        args.maxResults || 50,&#10;        issueTypes&#10;      );&#10;      return JSON.stringify({ sprint: activeSprint, issues }, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;await server.start({&#10;  transportType: 'stdio',&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>