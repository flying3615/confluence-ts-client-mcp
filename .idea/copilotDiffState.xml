<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/confluence/ConfluenceClient.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/confluence/ConfluenceClient.ts" />
              <option name="originalContent" value="import axios, { AxiosInstance } from 'axios';&#10;import {&#10;  ConfluencePage,&#10;  ConfluencePageListResponse,&#10;  ConfluenceSpaceListResponse,&#10;  ConfluenceCommentListResponse,&#10;  ConfluenceAttachmentListResponse,&#10;  ConfluenceAttachment,&#10;} from './confluenceTypes.js';&#10;&#10;export class ConfluenceClient {&#10;  private readonly client: AxiosInstance;&#10;&#10;  constructor(&#10;    private readonly domain: string,&#10;    private readonly user: string,&#10;    private readonly token: string&#10;  ) {&#10;    const authToken = Buffer.from(`${user}:${token}`).toString('base64');&#10;    this.client = axios.create({&#10;      baseURL: `https://${domain}/wiki/rest/api`,&#10;      headers: {&#10;        Authorization: `Basic ${authToken}`,&#10;        Accept: 'application/json',&#10;      },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get a Confluence page by its ID&#10;   * @param pageId The ID of the page to retrieve&#10;   * @param expand Fields to expand in the response (default: body.storage)&#10;   * @returns The page data&#10;   */&#10;  async getPageById(&#10;    pageId: string,&#10;    expand: string[] = ['body.storage']&#10;  ): Promise&lt;ConfluencePage&gt; {&#10;    try {&#10;      const response = await this.client.get(`/content/${pageId}`, {&#10;        params: { expand: expand.join(',') },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for content in Confluence using CQL (Confluence Query Language)&#10;   * @param cql The CQL search query string&#10;   * @returns Search results matching the query&#10;   * @example&#10;   * // Search for pages with title containing &quot;API&quot;&#10;   * client.search('title ~ &quot;API&quot;')&#10;   * // Search for pages in the DOCS space&#10;   * client.search('space = &quot;DOCS&quot;')&#10;   * // Search for pages updated by a specific user&#10;   * client.search('contributor = &quot;username&quot;')&#10;   */&#10;  async search(cql: string): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const response = await this.client.get('/content/search', {&#10;        params: { cql },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get pages by title&#10;   * @param title The title to search for&#10;   * @param spaceKey Optional space key to limit the search&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getPagesByTitle(&#10;    title: string,&#10;    spaceKey?: string,&#10;    expand: string[] = ['body.storage']&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      let cql = `title ~ &quot;${title}&quot;`;&#10;      if (spaceKey) {&#10;        cql += ` AND space = &quot;${spaceKey}&quot;`;&#10;      }&#10;&#10;      const response = await this.client.get('/content/search', {&#10;        params: {&#10;          cql,&#10;          expand: expand.join(','),&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all pages in a specific space&#10;   * @param spaceKey The key of the space&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getPagesBySpaceKey(&#10;    spaceKey: string,&#10;    limit: number = 25,&#10;    start: number = 0,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const response = await this.client.get('/content', {&#10;        params: {&#10;          spaceKey,&#10;          type: 'page',&#10;          limit,&#10;          start,&#10;          expand: expand.join(','),&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get child pages of a specific page&#10;   * @param pageId The ID of the parent page&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getPageChildren(&#10;    pageId: string,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const response = await this.client.get(`/content/${pageId}/child/page`, {&#10;        params: {&#10;          expand: expand.join(','),&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all spaces the user has access to&#10;   * @param type Type of spaces to return (global, personal)&#10;   * @param status Status of spaces to return (current, archived)&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   */&#10;  async getSpaces(&#10;    type?: 'global' | 'personal',&#10;    status?: 'current' | 'archived',&#10;    limit: number = 25,&#10;    start: number = 0&#10;  ): Promise&lt;ConfluenceSpaceListResponse&gt; {&#10;    try {&#10;      const response = await this.client.get('/space', {&#10;        params: {&#10;          type,&#10;          status,&#10;          limit,&#10;          start,&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get the version history of a page&#10;   * @param pageId The ID of the page&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   */&#10;  async getPageHistory(&#10;    pageId: string,&#10;    limit: number = 25,&#10;    start: number = 0&#10;  ): Promise&lt;any&gt; {&#10;    try {&#10;      const response = await this.client.get(`/content/${pageId}/history`, {&#10;        params: {&#10;          limit,&#10;          start,&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get comments associated with a page&#10;   * @param pageId The ID of the page&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getPageComments(&#10;    pageId: string,&#10;    limit: number = 25,&#10;    start: number = 0,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluenceCommentListResponse&gt; {&#10;    try {&#10;      const response = await this.client.get(&#10;        `/content/${pageId}/child/comment`,&#10;        {&#10;          params: {&#10;            limit,&#10;            start,&#10;            expand: expand.join(','),&#10;          },&#10;        }&#10;      );&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get attachments for a page&#10;   * @param pageId The ID of the page&#10;   * @param filename Optional filename to filter attachments&#10;   * @param mediaType Optional media type to filter attachments&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getAttachments(&#10;    pageId: string,&#10;    filename?: string,&#10;    mediaType?: string,&#10;    limit: number = 25,&#10;    start: number = 0,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluenceAttachmentListResponse&gt; {&#10;    try {&#10;      const response = await this.client.get(&#10;        `/content/${pageId}/child/attachment`,&#10;        {&#10;          params: {&#10;            filename,&#10;            mediaType,&#10;            limit,&#10;            start,&#10;            expand: expand.join(','),&#10;          },&#10;        }&#10;      );&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get a specific attachment&#10;   * @param attachmentId The ID of the attachment&#10;   */&#10;  async getAttachment(attachmentId: string): Promise&lt;ConfluenceAttachment&gt; {&#10;    try {&#10;      const response = await this.client.get(`/content/${attachmentId}`);&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Download attachment content&#10;   * @param attachmentId The ID of the attachment&#10;   */&#10;  async downloadAttachment(attachmentId: string): Promise&lt;{&#10;    data: ArrayBuffer;&#10;    contentType: string;&#10;    filename: string;&#10;  }&gt; {&#10;    try {&#10;      const attachment = await this.getAttachment(attachmentId);&#10;      const downloadUrl = attachment?._links?.download;&#10;&#10;      if (!downloadUrl) {&#10;        throw new Error('Download link not available');&#10;      }&#10;&#10;      const response = await this.client.get(downloadUrl, {&#10;        responseType: 'arraybuffer',&#10;      });&#10;&#10;      return {&#10;        data: response.data,&#10;        contentType: response.headers['content-type'],&#10;        filename: attachment.title,&#10;      };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get recently updated content&#10;   * @param spaceKey Optional space key to filter results&#10;   * @param type Content type to filter by&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getRecentlyUpdated(&#10;    spaceKey?: string,&#10;    type: 'page' | 'blogpost' | 'comment' | 'attachment' = 'page',&#10;    limit: number = 25,&#10;    start: number = 0,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const params: any = {&#10;        type,&#10;        limit,&#10;        start,&#10;        expand: expand.join(','),&#10;        orderby: 'modified',&#10;      };&#10;&#10;      if (spaceKey) {&#10;        params.spaceKey = spaceKey;&#10;      }&#10;&#10;      const response = await this.client.get('/content', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get content by label&#10;   * @param labelName The name of the label to search for&#10;   * @param spaceKey Optional space key to filter results&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   */&#10;  async getContentByLabel(&#10;    labelName: string,&#10;    spaceKey?: string,&#10;    limit: number = 25,&#10;    start: number = 0&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const params: any = {&#10;        labelName,&#10;        limit,&#10;        start,&#10;      };&#10;&#10;      if (spaceKey) {&#10;        params.spaceKey = spaceKey;&#10;      }&#10;&#10;      const response = await this.client.get('/content/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get labels for content&#10;   * @param contentId The ID of the content&#10;   * @param prefix Optional prefix to filter labels&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   */&#10;  async getContentLabels(&#10;    contentId: string,&#10;    prefix?: string,&#10;    limit: number = 25,&#10;    start: number = 0&#10;  ): Promise&lt;any&gt; {&#10;    try {&#10;      const response = await this.client.get(`/content/${contentId}/label`, {&#10;        params: {&#10;          prefix,&#10;          limit,&#10;          start,&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Find pages that are topically related to a given page&#10;   * This uses several approaches to find relevant pages:&#10;   * 1. Pages with similar titles&#10;   * 2. Pages with shared labels&#10;   * 3. Pages that link to or are linked from the target page&#10;   *&#10;   * @param pageId The ID of the reference page&#10;   * @param limit Maximum number of results to return&#10;   * @param expand Fields to expand in the response&#10;   * @returns List of related pages&#10;   */&#10;  async getTopicallyRelatedPages(&#10;    pageId: string,&#10;    limit: number = 10,&#10;    expand: string[] = ['body.storage']&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      // First get the source page to extract title and labels&#10;      const sourcePage = await this.getPageById(pageId, ['metadata.labels']);&#10;      const title = sourcePage.title;&#10;&#10;      // Extract keywords from the title (remove common words)&#10;      const keywords = title&#10;        .split(/\s+/)&#10;        .filter(word =&gt; word.length &gt; 3)&#10;        .map(word =&gt; word.replace(/[^\w\s]/g, ''));&#10;&#10;      // Build a CQL query to find related content&#10;      let relatedQuery = `type = page AND id != ${pageId}`;&#10;&#10;      // Add title similarity condition if we have keywords&#10;      if (keywords.length &gt; 0) {&#10;        const titleTerms = keywords&#10;          .map(word =&gt; `title ~ &quot;${word}&quot;`)&#10;          .join(' OR ');&#10;        relatedQuery += ` AND (${titleTerms})`;&#10;      }&#10;&#10;      // Add label conditions if the page has labels&#10;      const labels = sourcePage.metadata?.labels?.results || [];&#10;      if (labels.length &gt; 0) {&#10;        const labelNames = labels.map(label =&gt; label.name);&#10;        const labelTerms = labelNames&#10;          .map(name =&gt; `labelText = &quot;${name}&quot;`)&#10;          .join(' OR ');&#10;        // Combine with OR to broaden results&#10;        relatedQuery +=&#10;          keywords.length &gt; 0 ? ` OR (${labelTerms})` : ` AND (${labelTerms})`;&#10;      }&#10;&#10;      // Execute the search&#10;      const response = await this.client.get('/content/search', {&#10;        params: {&#10;          cql: relatedQuery,&#10;          limit,&#10;          expand: expand.join(','),&#10;        },&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  private handleError(error: any): never {&#10;    if (error.response) {&#10;      console.error(&#10;        `Error: ${error.response.status} - ${error.response.statusText}`&#10;      );&#10;      if (error.response.status === 401) {&#10;        console.error(&#10;          'Authentication failed. Please check your email and API token.'&#10;        );&#10;      } else if (error.response.status === 404) {&#10;        console.error(&#10;          'Resource not found. Please check your Confluence domain and the requested resource.'&#10;        );&#10;      }&#10;    } else {&#10;      console.error('An unexpected error occurred:', error.message);&#10;    }&#10;    throw error;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import axios, { AxiosInstance } from 'axios';&#10;import https from 'https';&#10;import {&#10;  ConfluencePage,&#10;  ConfluencePageListResponse,&#10;  ConfluenceSpaceListResponse,&#10;  ConfluenceCommentListResponse,&#10;  ConfluenceAttachmentListResponse,&#10;  ConfluenceAttachment,&#10;} from './confluenceTypes.js';&#10;&#10;export class ConfluenceClient {&#10;  private readonly client: AxiosInstance;&#10;&#10;  constructor(&#10;    private readonly domain: string,&#10;    private readonly user: string,&#10;    private readonly token: string&#10;  ) {&#10;    const authToken = Buffer.from(`${user}:${token}`).toString('base64');&#10;    this.client = axios.create({&#10;      baseURL: `https://${domain}/wiki/rest/api`,&#10;      headers: {&#10;        Authorization: `Basic ${authToken}`,&#10;        Accept: 'application/json',&#10;      },&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Get a Confluence page by its ID&#10;   * @param pageId The ID of the page to retrieve&#10;   * @param expand Fields to expand in the response (default: body.storage)&#10;   * @returns The page data&#10;   */&#10;  async getPageById(&#10;    pageId: string,&#10;    expand: string[] = ['body.storage']&#10;  ): Promise&lt;ConfluencePage&gt; {&#10;    try {&#10;      const config = { httpsAgent: new https.Agent({ rejectUnauthorized: false }) };&#10;      const response = await this.client.get(`/content/${pageId}`, {&#10;        params: { expand: expand.join(',') },&#10;        ...config,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for content in Confluence using CQL (Confluence Query Language)&#10;   * @param cql The CQL search query string&#10;   * @returns Search results matching the query&#10;   * @example&#10;   * // Search for pages with title containing &quot;API&quot;&#10;   * client.search('title ~ &quot;API&quot;')&#10;   * // Search for pages in the DOCS space&#10;   * client.search('space = &quot;DOCS&quot;')&#10;   * // Search for pages updated by a specific user&#10;   * client.search('contributor = &quot;username&quot;')&#10;   */&#10;  async search(cql: string): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const config = { httpsAgent: new https.Agent({ rejectUnauthorized: false }) };&#10;      const response = await this.client.get('/content/search', {&#10;        params: { cql },&#10;        ...config,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get pages by title&#10;   * @param title The title to search for&#10;   * @param spaceKey Optional space key to limit the search&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getPagesByTitle(&#10;    title: string,&#10;    spaceKey?: string,&#10;    expand: string[] = ['body.storage']&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      let cql = `title ~ &quot;${title}&quot;`;&#10;      if (spaceKey) {&#10;        cql += ` AND space = &quot;${spaceKey}&quot;`;&#10;      }&#10;&#10;      const response = await this.client.get('/content/search', {&#10;        params: {&#10;          cql,&#10;          expand: expand.join(','),&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all pages in a specific space&#10;   * @param spaceKey The key of the space&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getPagesBySpaceKey(&#10;    spaceKey: string,&#10;    limit: number = 25,&#10;    start: number = 0,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const config = { httpsAgent: new https.Agent({ rejectUnauthorized: false }) };&#10;      const response = await this.client.get('/content', {&#10;        params: {&#10;          spaceKey,&#10;          type: 'page',&#10;          limit,&#10;          start,&#10;          expand: expand.join(','),&#10;        },&#10;        ...config,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get child pages of a specific page&#10;   * @param pageId The ID of the parent page&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getPageChildren(&#10;    pageId: string,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const config = { httpsAgent: new https.Agent({ rejectUnauthorized: false }) };&#10;      const response = await this.client.get(`/content/${pageId}/child/page`, {&#10;        params: {&#10;          expand: expand.join(','),&#10;        },&#10;        ...config,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all spaces the user has access to&#10;   * @param type Type of spaces to return (global, personal)&#10;   * @param status Status of spaces to return (current, archived)&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   */&#10;  async getSpaces(&#10;    type?: 'global' | 'personal',&#10;    status?: 'current' | 'archived',&#10;    limit: number = 25,&#10;    start: number = 0&#10;  ): Promise&lt;ConfluenceSpaceListResponse&gt; {&#10;    try {&#10;      const response = await this.client.get('/space', {&#10;        params: {&#10;          type,&#10;          status,&#10;          limit,&#10;          start,&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get the version history of a page&#10;   * @param pageId The ID of the page&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   */&#10;  async getPageHistory(&#10;    pageId: string,&#10;    limit: number = 25,&#10;    start: number = 0&#10;  ): Promise&lt;any&gt; {&#10;    try {&#10;      const response = await this.client.get(`/content/${pageId}/history`, {&#10;        params: {&#10;          limit,&#10;          start,&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get comments associated with a page&#10;   * @param pageId The ID of the page&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getPageComments(&#10;    pageId: string,&#10;    limit: number = 25,&#10;    start: number = 0,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluenceCommentListResponse&gt; {&#10;    try {&#10;      const response = await this.client.get(&#10;        `/content/${pageId}/child/comment`,&#10;        {&#10;          params: {&#10;            limit,&#10;            start,&#10;            expand: expand.join(','),&#10;          },&#10;        }&#10;      );&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get attachments for a page&#10;   * @param pageId The ID of the page&#10;   * @param filename Optional filename to filter attachments&#10;   * @param mediaType Optional media type to filter attachments&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getAttachments(&#10;    pageId: string,&#10;    filename?: string,&#10;    mediaType?: string,&#10;    limit: number = 25,&#10;    start: number = 0,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluenceAttachmentListResponse&gt; {&#10;    try {&#10;      const response = await this.client.get(&#10;        `/content/${pageId}/child/attachment`,&#10;        {&#10;          params: {&#10;            filename,&#10;            mediaType,&#10;            limit,&#10;            start,&#10;            expand: expand.join(','),&#10;          },&#10;        }&#10;      );&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get a specific attachment&#10;   * @param attachmentId The ID of the attachment&#10;   */&#10;  async getAttachment(attachmentId: string): Promise&lt;ConfluenceAttachment&gt; {&#10;    try {&#10;      const response = await this.client.get(`/content/${attachmentId}`);&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Download attachment content&#10;   * @param attachmentId The ID of the attachment&#10;   */&#10;  async downloadAttachment(attachmentId: string): Promise&lt;{&#10;    data: ArrayBuffer;&#10;    contentType: string;&#10;    filename: string;&#10;  }&gt; {&#10;    try {&#10;      const attachment = await this.getAttachment(attachmentId);&#10;      const downloadUrl = attachment?._links?.download;&#10;&#10;      if (!downloadUrl) {&#10;        throw new Error('Download link not available');&#10;      }&#10;&#10;      const response = await this.client.get(downloadUrl, {&#10;        responseType: 'arraybuffer',&#10;      });&#10;&#10;      return {&#10;        data: response.data,&#10;        contentType: response.headers['content-type'],&#10;        filename: attachment.title,&#10;      };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get recently updated content&#10;   * @param spaceKey Optional space key to filter results&#10;   * @param type Content type to filter by&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   * @param expand Fields to expand in the response&#10;   */&#10;  async getRecentlyUpdated(&#10;    spaceKey?: string,&#10;    type: 'page' | 'blogpost' | 'comment' | 'attachment' = 'page',&#10;    limit: number = 25,&#10;    start: number = 0,&#10;    expand: string[] = []&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const params: any = {&#10;        type,&#10;        limit,&#10;        start,&#10;        expand: expand.join(','),&#10;        orderby: 'modified',&#10;      };&#10;&#10;      if (spaceKey) {&#10;        params.spaceKey = spaceKey;&#10;      }&#10;&#10;      const response = await this.client.get('/content', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get content by label&#10;   * @param labelName The name of the label to search for&#10;   * @param spaceKey Optional space key to filter results&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   */&#10;  async getContentByLabel(&#10;    labelName: string,&#10;    spaceKey?: string,&#10;    limit: number = 25,&#10;    start: number = 0&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      const params: any = {&#10;        labelName,&#10;        limit,&#10;        start,&#10;      };&#10;&#10;      if (spaceKey) {&#10;        params.spaceKey = spaceKey;&#10;      }&#10;&#10;      const response = await this.client.get('/content/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get labels for content&#10;   * @param contentId The ID of the content&#10;   * @param prefix Optional prefix to filter labels&#10;   * @param limit Maximum number of results to return&#10;   * @param start Start index for pagination&#10;   */&#10;  async getContentLabels(&#10;    contentId: string,&#10;    prefix?: string,&#10;    limit: number = 25,&#10;    start: number = 0&#10;  ): Promise&lt;any&gt; {&#10;    try {&#10;      const response = await this.client.get(`/content/${contentId}/label`, {&#10;        params: {&#10;          prefix,&#10;          limit,&#10;          start,&#10;        },&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Find pages that are topically related to a given page&#10;   * This uses several approaches to find relevant pages:&#10;   * 1. Pages with similar titles&#10;   * 2. Pages with shared labels&#10;   * 3. Pages that link to or are linked from the target page&#10;   *&#10;   * @param pageId The ID of the reference page&#10;   * @param limit Maximum number of results to return&#10;   * @param expand Fields to expand in the response&#10;   * @returns List of related pages&#10;   */&#10;  async getTopicallyRelatedPages(&#10;    pageId: string,&#10;    limit: number = 10,&#10;    expand: string[] = ['body.storage']&#10;  ): Promise&lt;ConfluencePageListResponse&gt; {&#10;    try {&#10;      // First get the source page to extract title and labels&#10;      const sourcePage = await this.getPageById(pageId, ['metadata.labels']);&#10;      const title = sourcePage.title;&#10;&#10;      // Extract keywords from the title (remove common words)&#10;      const keywords = title&#10;        .split(/\s+/)&#10;        .filter(word =&gt; word.length &gt; 3)&#10;        .map(word =&gt; word.replace(/[^\w\s]/g, ''));&#10;&#10;      // Build a CQL query to find related content&#10;      let relatedQuery = `type = page AND id != ${pageId}`;&#10;&#10;      // Add title similarity condition if we have keywords&#10;      if (keywords.length &gt; 0) {&#10;        const titleTerms = keywords&#10;          .map(word =&gt; `title ~ &quot;${word}&quot;`)&#10;          .join(' OR ');&#10;        relatedQuery += ` AND (${titleTerms})`;&#10;      }&#10;&#10;      // Add label conditions if the page has labels&#10;      const labels = sourcePage.metadata?.labels?.results || [];&#10;      if (labels.length &gt; 0) {&#10;        const labelNames = labels.map(label =&gt; label.name);&#10;        const labelTerms = labelNames&#10;          .map(name =&gt; `labelText = &quot;${name}&quot;`)&#10;          .join(' OR ');&#10;        // Combine with OR to broaden results&#10;        relatedQuery +=&#10;          keywords.length &gt; 0 ? ` OR (${labelTerms})` : ` AND (${labelTerms})`;&#10;      }&#10;&#10;      // Execute the search&#10;      const response = await this.client.get('/content/search', {&#10;        params: {&#10;          cql: relatedQuery,&#10;          limit,&#10;          expand: expand.join(','),&#10;        },&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  private handleError(error: any): never {&#10;    if (error.response) {&#10;      console.error(&#10;        `Error: ${error.response.status} - ${error.response.statusText}`&#10;      );&#10;      if (error.response.status === 401) {&#10;        console.error(&#10;          'Authentication failed. Please check your email and API token.'&#10;        );&#10;      } else if (error.response.status === 404) {&#10;        console.error(&#10;          'Resource not found. Please check your Confluence domain and the requested resource.'&#10;        );&#10;      }&#10;    } else {&#10;      console.error('An unexpected error occurred:', error.message);&#10;    }&#10;    throw error;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/jira/JiraClient.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/jira/JiraClient.ts" />
              <option name="originalContent" value="import axios, { AxiosInstance } from 'axios';&#10;import {&#10;  JiraIssue,&#10;  JiraIssueListResponse,&#10;  JiraProject,&#10;  JiraProjectListResponse,&#10;  JiraBoard,&#10;  JiraBoardListResponse,&#10;  JiraSprint,&#10;  JiraSprintListResponse,&#10;  JiraUser,&#10;  JiraComment,&#10;  JiraCommentListResponse,&#10;  JiraWorklog,&#10;  JiraWorklogListResponse,&#10;  JiraSearchResponse,&#10;  JiraTransition,&#10;} from './jiraTypes.js';&#10;import { JiraIssueExtractor } from './JiraIssueExtractor.js';&#10;&#10;export class JiraClient {&#10;  private readonly client: AxiosInstance;&#10;  private readonly issueExtractor: JiraIssueExtractor;&#10;&#10;  constructor(&#10;    private readonly domain: string,&#10;    private readonly user: string,&#10;    private readonly token: string&#10;  ) {&#10;    const authToken = Buffer.from(`${user}:${token}`).toString('base64');&#10;    this.client = axios.create({&#10;      baseURL: `https://${domain}/rest/api/3`,&#10;      headers: {&#10;        Authorization: `Basic ${authToken}`,&#10;        Accept: 'application/json',&#10;        'Content-Type': 'application/json',&#10;      },&#10;    });&#10;    this.issueExtractor = new JiraIssueExtractor();&#10;  }&#10;&#10;  // TODO: default active sprint, MCP use prompt to rewrite this issue discription&#10;  /**&#10;   * Get a Jira issue by its key&#10;   * @param issueKey The key of the issue to retrieve (e.g., PROJECT-123)&#10;   * @param fields Optional array of field names to include&#10;   * @returns The issue data&#10;   */&#10;  async getIssue(issueKey: string, fields?: string[]): Promise&lt;JiraIssue&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {};&#10;      if (fields &amp;&amp; fields.length &gt; 0) {&#10;        params.fields = fields.join(',');&#10;      }&#10;&#10;      const response = await this.client.get(`/issue/${issueKey}`, { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for Jira issues using JQL (Jira Query Language)&#10;   * @param jql The JQL search query string&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @param fields Optional array of field names to include&#10;   * @returns Search results matching the query&#10;   * @example&#10;   * // Search for issues in the PROJECT project&#10;   * client.searchIssues('project = PROJECT')&#10;   * // Search for open bugs assigned to the current user&#10;   * client.searchIssues('type = Bug AND status = &quot;Open&quot; AND assignee = currentUser()')&#10;   */&#10;  async searchIssues(&#10;    jql: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50,&#10;    fields?: string[]&#10;  ): Promise&lt;JiraSearchResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        jql,&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (fields &amp;&amp; fields.length &gt; 0) {&#10;        params.fields = fields.join(',');&#10;      }&#10;&#10;      const response = await this.client.get('/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all projects the user has access to&#10;   * @param recent Get only recently accessed projects&#10;   * @returns List of projects&#10;   */&#10;  async getProjects(recent: boolean = false): Promise&lt;JiraProjectListResponse&gt; {&#10;    try {&#10;      const endpoint = recent ? '/project/recent' : '/project';&#10;      const response = await this.client.get(endpoint);&#10;      return { projects: response.data };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get a specific project by its key&#10;   * @param projectKey The key of the project to retrieve&#10;   * @returns The project data&#10;   */&#10;  async getProject(projectKey: string): Promise&lt;JiraProject&gt; {&#10;    try {&#10;      const response = await this.client.get(`/project/${projectKey}`);&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all boards visible to the user&#10;   * @param projectKeyOrId Optional project key to filter boards&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of boards&#10;   */&#10;  async getBoards(&#10;    projectKeyOrId?: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraBoardListResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (projectKeyOrId) {&#10;        params.projectKeyOrId = projectKeyOrId;&#10;      }&#10;&#10;      // Note: Boards use a different API endpoint&#10;      const response = await this.client.get('/board', {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all sprints in a board&#10;   * @param boardId The ID of the board&#10;   * @param state Optional filter for sprint state (future, active, closed)&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of sprints&#10;   */&#10;  async getSprints(&#10;    boardId: number,&#10;    state?: 'future' | 'active' | 'closed',&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraSprintListResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (state) {&#10;        params.state = state;&#10;      }&#10;&#10;      const response = await this.client.get(`/board/${boardId}/sprint`, {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all issues in a sprint, optionally filtered by a list of issue types&#10;   * @param sprintId The ID of the sprint&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @param issueTypes Optional array of issue types to filter (e.g., ['Story', 'Bug', 'Epic', 'Sub-task'])&#10;   * @returns List of issues (filtered if issueTypes is provided)&#10;   */&#10;  async getSprintIssues(&#10;    sprintId: number,&#10;    startAt: number = 0,&#10;    maxResults: number = 50,&#10;    issueTypes?: string[]&#10;  ): Promise&lt;JiraIssueListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/sprint/${sprintId}/issue`, {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      let issues = response.data.issues;&#10;      if (issueTypes &amp;&amp; Array.isArray(issueTypes) &amp;&amp; issueTypes.length &gt; 0) {&#10;        issues = issues.filter((issue: any) =&gt;&#10;          issueTypes.includes(issue.fields.issuetype?.name)&#10;        );&#10;      }&#10;      return { ...response.data, issues };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all users in the Jira instance&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of users&#10;   */&#10;  async getUsers(&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraUser[]&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/users/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for users by query string&#10;   * @param query The search query&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of matching users&#10;   */&#10;  async searchUsers(&#10;    query: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraUser[]&gt; {&#10;    try {&#10;      const params = {&#10;        query,&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/user/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get comments for an issue&#10;   * @param issueKey The key of the issue&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of comments&#10;   */&#10;  async getIssueComments(&#10;    issueKey: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraCommentListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/issue/${issueKey}/comment`, {&#10;        params,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all work logs for an issue&#10;   * @param issueKey The key of the issue&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of work logs&#10;   */&#10;  async getIssueWorklogs(&#10;    issueKey: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraWorklogListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/issue/${issueKey}/worklog`, {&#10;        params,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get issue types for a project&#10;   * @param projectIdOrKey The ID or key of the project&#10;   * @returns List of issue types&#10;   */&#10;  async getIssueTypes(projectIdOrKey: string): Promise&lt;any[]&gt; {&#10;    try {&#10;      const response = await this.client.get(&#10;        `/project/${projectIdOrKey}/statuses`&#10;      );&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get available transitions for an issue&#10;   * @param issueKey The key of the issue&#10;   * @returns List of available transitions&#10;   */&#10;  async getIssueTransitions(issueKey: string): Promise&lt;JiraTransition[]&gt; {&#10;    try {&#10;      const response = await this.client.get(`/issue/${issueKey}/transitions`);&#10;      return response.data.transitions;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Find related issues for a given issue&#10;   * @param issueKey The key of the issue to find related issues for&#10;   * @returns List of related issues&#10;   */&#10;  async getRelatedIssues(issueKey: string): Promise&lt;JiraIssue[]&gt; {&#10;    try {&#10;      // First get the issue to extract project, labels, etc.&#10;      const issue = await this.getIssue(issueKey, [&#10;        'summary',&#10;        'labels',&#10;        'project',&#10;      ]);&#10;&#10;      // Build a JQL query to find related issues&#10;      const relatedQueries = [];&#10;&#10;      // Issues in the same project&#10;      relatedQueries.push(`project = ${issue.fields.project.key}`);&#10;&#10;      // Issues with similar summary (extract keywords)&#10;      if (issue.fields.summary) {&#10;        const keywords = issue.fields.summary&#10;          .split(/\s+/)&#10;          .filter(word =&gt; word.length &gt; 3)&#10;          .map(word =&gt; word.replace(/[^\w\s]/g, ''));&#10;&#10;        if (keywords.length &gt; 0) {&#10;          const keywordQuery = keywords&#10;            .map(word =&gt; `summary ~ &quot;${word}&quot;`)&#10;            .join(' OR ');&#10;          relatedQueries.push(`(${keywordQuery})`);&#10;        }&#10;      }&#10;&#10;      // Issues with shared labels&#10;      if (issue.fields.labels &amp;&amp; issue.fields.labels.length &gt; 0) {&#10;        const labelQuery = issue.fields.labels&#10;          .map(label =&gt; `labels = &quot;${label}&quot;`)&#10;          .join(' OR ');&#10;        relatedQueries.push(`(${labelQuery})`);&#10;      }&#10;&#10;      // Combine queries and exclude the original issue&#10;      const jql = `(${relatedQueries.join(' OR ')}) AND issuekey != ${issueKey} ORDER BY updated DESC`;&#10;&#10;      // Execute search with the constructed JQL&#10;      const searchResult = await this.searchIssues(jql, 0, 10);&#10;      return searchResult.issues;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all dashboards available to the user&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of dashboards&#10;   */&#10;  async getDashboards(&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;any&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/dashboard', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  private handleError(error: any): never {&#10;    if (error.response) {&#10;      console.error(&#10;        `Error: ${error.response.status} - ${error.response.statusText}`&#10;      );&#10;      if (error.response.status === 401) {&#10;        console.error(&#10;          'Authentication failed. Please check your email and API token.'&#10;        );&#10;      } else if (error.response.status === 403) {&#10;        console.error(&#10;          'Permission denied. You do not have access to this resource.'&#10;        );&#10;      } else if (error.response.status === 404) {&#10;        console.error(&#10;          'Resource not found. Please check the requested resource exists.'&#10;        );&#10;      }&#10;    } else {&#10;      console.error('An unexpected error occurred:', error.message);&#10;    }&#10;    throw error;&#10;  }&#10;&#10;  /**&#10;   * Extract formatted details from a Jira issue&#10;   * @param issue The Jira issue to extract details from&#10;   * @returns Formatted string with issue details&#10;   */&#10;  extractIssueDetails(issue: JiraIssue): string {&#10;    return this.issueExtractor.extractIssueDetails(issue);&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import axios, { AxiosInstance } from 'axios';&#10;import {&#10;  JiraIssue,&#10;  JiraIssueListResponse,&#10;  JiraProject,&#10;  JiraProjectListResponse,&#10;  JiraBoard,&#10;  JiraBoardListResponse,&#10;  JiraSprint,&#10;  JiraSprintListResponse,&#10;  JiraUser,&#10;  JiraComment,&#10;  JiraCommentListResponse,&#10;  JiraWorklog,&#10;  JiraWorklogListResponse,&#10;  JiraSearchResponse,&#10;  JiraTransition,&#10;} from './jiraTypes.js';&#10;import { JiraIssueExtractor } from './JiraIssueExtractor.js';&#10;import https from 'https';&#10;&#10;export class JiraClient {&#10;  private readonly client: AxiosInstance;&#10;  private readonly issueExtractor: JiraIssueExtractor;&#10;&#10;  constructor(&#10;    private readonly domain: string,&#10;    private readonly user: string,&#10;    private readonly token: string&#10;  ) {&#10;    const authToken = Buffer.from(`${user}:${token}`).toString('base64');&#10;    this.client = axios.create({&#10;      baseURL: `https://${domain}/rest/api/3`,&#10;      headers: {&#10;        Authorization: `Basic ${authToken}`,&#10;        Accept: 'application/json',&#10;        'Content-Type': 'application/json',&#10;      },&#10;    });&#10;    this.issueExtractor = new JiraIssueExtractor();&#10;  }&#10;&#10;  // TODO: default active sprint, MCP use prompt to rewrite this issue discription&#10;  /**&#10;   * Get a Jira issue by its key&#10;   * @param issueKey The key of the issue to retrieve (e.g., PROJECT-123)&#10;   * @param fields Optional array of field names to include&#10;   * @returns The issue data&#10;   */&#10;  async getIssue(issueKey: string, fields?: string[]): Promise&lt;JiraIssue&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {};&#10;      if (fields &amp;&amp; fields.length &gt; 0) {&#10;        params.fields = fields.join(',');&#10;      }&#10;      const config = { httpsAgent: new https.Agent({ rejectUnauthorized: false }) };&#10;      const response = await this.client.get(`/issue/${issueKey}`, { params, ...config });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for Jira issues using JQL (Jira Query Language)&#10;   * @param jql The JQL search query string&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @param fields Optional array of field names to include&#10;   * @returns Search results matching the query&#10;   * @example&#10;   * // Search for issues in the PROJECT project&#10;   * client.searchIssues('project = PROJECT')&#10;   * // Search for open bugs assigned to the current user&#10;   * client.searchIssues('type = Bug AND status = &quot;Open&quot; AND assignee = currentUser()')&#10;   */&#10;  async searchIssues(&#10;    jql: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50,&#10;    fields?: string[]&#10;  ): Promise&lt;JiraSearchResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        jql,&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (fields &amp;&amp; fields.length &gt; 0) {&#10;        params.fields = fields.join(',');&#10;      }&#10;&#10;      const response = await this.client.get('/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all projects the user has access to&#10;   * @param recent Get only recently accessed projects&#10;   * @returns List of projects&#10;   */&#10;  async getProjects(recent: boolean = false): Promise&lt;JiraProjectListResponse&gt; {&#10;    try {&#10;      const endpoint = recent ? '/project/recent' : '/project';&#10;      const response = await this.client.get(endpoint);&#10;      return { projects: response.data };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get a specific project by its key&#10;   * @param projectKey The key of the project to retrieve&#10;   * @returns The project data&#10;   */&#10;  async getProject(projectKey: string): Promise&lt;JiraProject&gt; {&#10;    try {&#10;      const response = await this.client.get(`/project/${projectKey}`);&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all boards visible to the user&#10;   * @param projectKeyOrId Optional project key to filter boards&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of boards&#10;   */&#10;  async getBoards(&#10;    projectKeyOrId?: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraBoardListResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (projectKeyOrId) {&#10;        params.projectKeyOrId = projectKeyOrId;&#10;      }&#10;&#10;      // Note: Boards use a different API endpoint&#10;      const response = await this.client.get('/board', {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all sprints in a board&#10;   * @param boardId The ID of the board&#10;   * @param state Optional filter for sprint state (future, active, closed)&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of sprints&#10;   */&#10;  async getSprints(&#10;    boardId: number,&#10;    state?: 'future' | 'active' | 'closed',&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraSprintListResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (state) {&#10;        params.state = state;&#10;      }&#10;&#10;      const response = await this.client.get(`/board/${boardId}/sprint`, {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all issues in a sprint, optionally filtered by a list of issue types&#10;   * @param sprintId The ID of the sprint&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @param issueTypes Optional array of issue types to filter (e.g., ['Story', 'Bug', 'Epic', 'Sub-task'])&#10;   * @returns List of issues (filtered if issueTypes is provided)&#10;   */&#10;  async getSprintIssues(&#10;    sprintId: number,&#10;    startAt: number = 0,&#10;    maxResults: number = 50,&#10;    issueTypes?: string[]&#10;  ): Promise&lt;JiraIssueListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/sprint/${sprintId}/issue`, {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      let issues = response.data.issues;&#10;      if (issueTypes &amp;&amp; Array.isArray(issueTypes) &amp;&amp; issueTypes.length &gt; 0) {&#10;        issues = issues.filter((issue: any) =&gt;&#10;          issueTypes.includes(issue.fields.issuetype?.name)&#10;        );&#10;      }&#10;      return { ...response.data, issues };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all users in the Jira instance&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of users&#10;   */&#10;  async getUsers(&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraUser[]&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/users/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for users by query string&#10;   * @param query The search query&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of matching users&#10;   */&#10;  async searchUsers(&#10;    query: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraUser[]&gt; {&#10;    try {&#10;      const params = {&#10;        query,&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/user/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get comments for an issue&#10;   * @param issueKey The key of the issue&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of comments&#10;   */&#10;  async getIssueComments(&#10;    issueKey: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraCommentListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/issue/${issueKey}/comment`, {&#10;        params,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all work logs for an issue&#10;   * @param issueKey The key of the issue&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of work logs&#10;   */&#10;  async getIssueWorklogs(&#10;    issueKey: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraWorklogListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/issue/${issueKey}/worklog`, {&#10;        params,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get issue types for a project&#10;   * @param projectIdOrKey The ID or key of the project&#10;   * @returns List of issue types&#10;   */&#10;  async getIssueTypes(projectIdOrKey: string): Promise&lt;any[]&gt; {&#10;    try {&#10;      const response = await this.client.get(&#10;        `/project/${projectIdOrKey}/statuses`&#10;      );&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get available transitions for an issue&#10;   * @param issueKey The key of the issue&#10;   * @returns List of available transitions&#10;   */&#10;  async getIssueTransitions(issueKey: string): Promise&lt;JiraTransition[]&gt; {&#10;    try {&#10;      const response = await this.client.get(`/issue/${issueKey}/transitions`);&#10;      return response.data.transitions;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Find related issues for a given issue&#10;   * @param issueKey The key of the issue to find related issues for&#10;   * @returns List of related issues&#10;   */&#10;  async getRelatedIssues(issueKey: string): Promise&lt;JiraIssue[]&gt; {&#10;    try {&#10;      // First get the issue to extract project, labels, etc.&#10;      const issue = await this.getIssue(issueKey, [&#10;        'summary',&#10;        'labels',&#10;        'project',&#10;      ]);&#10;&#10;      // Build a JQL query to find related issues&#10;      const relatedQueries = [];&#10;&#10;      // Issues in the same project&#10;      relatedQueries.push(`project = ${issue.fields.project.key}`);&#10;&#10;      // Issues with similar summary (extract keywords)&#10;      if (issue.fields.summary) {&#10;        const keywords = issue.fields.summary&#10;          .split(/\s+/)&#10;          .filter(word =&gt; word.length &gt; 3)&#10;          .map(word =&gt; word.replace(/[^\w\s]/g, ''));&#10;&#10;        if (keywords.length &gt; 0) {&#10;          const keywordQuery = keywords&#10;            .map(word =&gt; `summary ~ &quot;${word}&quot;`)&#10;            .join(' OR ');&#10;          relatedQueries.push(`(${keywordQuery})`);&#10;        }&#10;      }&#10;&#10;      // Issues with shared labels&#10;      if (issue.fields.labels &amp;&amp; issue.fields.labels.length &gt; 0) {&#10;        const labelQuery = issue.fields.labels&#10;          .map(label =&gt; `labels = &quot;${label}&quot;`)&#10;          .join(' OR ');&#10;        relatedQueries.push(`(${labelQuery})`);&#10;      }&#10;&#10;      // Combine queries and exclude the original issue&#10;      const jql = `(${relatedQueries.join(' OR ')}) AND issuekey != ${issueKey} ORDER BY updated DESC`;&#10;&#10;      // Execute search with the constructed JQL&#10;      const searchResult = await this.searchIssues(jql, 0, 10);&#10;      return searchResult.issues;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all dashboards available to the user&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of dashboards&#10;   */&#10;  async getDashboards(&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;any&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/dashboard', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  private handleError(error: any): never {&#10;    if (error.response) {&#10;      console.error(&#10;        `Error: ${error.response.status} - ${error.response.statusText}`&#10;      );&#10;      if (error.response.status === 401) {&#10;        console.error(&#10;          'Authentication failed. Please check your email and API token.'&#10;        );&#10;      } else if (error.response.status === 403) {&#10;        console.error(&#10;          'Permission denied. You do not have access to this resource.'&#10;        );&#10;      } else if (error.response.status === 404) {&#10;        console.error(&#10;          'Resource not found. Please check the requested resource exists.'&#10;        );&#10;      }&#10;    } else {&#10;      console.error('An unexpected error occurred:', error.message);&#10;    }&#10;    throw error;&#10;  }&#10;&#10;  /**&#10;   * Extract formatted details from a Jira issue&#10;   * @param issue The Jira issue to extract details from&#10;   * @returns Formatted string with issue details&#10;   */&#10;  extractIssueDetails(issue: JiraIssue): string {&#10;    return this.issueExtractor.extractIssueDetails(issue);&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>