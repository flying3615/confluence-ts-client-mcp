<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="originalContent" value="#!/usr/bin/env node&#10;&#10;import { FastMCP, UserError } from 'fastmcp';&#10;import { z } from 'zod';&#10;import { ConfluenceClient } from './confluence/ConfluenceClient.js';&#10;import { SimplePageResult } from './confluence/confluenceTypes.js';&#10;import { JiraClient } from './jira/JiraClient.js';&#10;import 'dotenv/config';&#10;&#10;// Initialize clients&#10;let client: ConfluenceClient;&#10;let jiraClient: JiraClient;&#10;&#10;export enum AtlassianServiceType {&#10;  Confluence = 'confluence',&#10;  Jira = 'jira',&#10;}&#10;&#10;function initAtlassianClient&lt;T extends AtlassianServiceType&gt;(&#10;  type: T&#10;): T extends AtlassianServiceType.Confluence ? ConfluenceClient : JiraClient {&#10;  const { ATLASSIAN_DOMAIN, ATLASSIAN_USER, ATLASSIAN_TOKEN } = process.env;&#10;  if (!ATLASSIAN_DOMAIN || !ATLASSIAN_USER || !ATLASSIAN_TOKEN) {&#10;    throw new UserError(&#10;      'Please set ATLASSIAN_DOMAIN, ATLASSIAN_USER, and ATLASSIAN_TOKEN in the .env file'&#10;    );&#10;  }&#10;  if (type === AtlassianServiceType.Confluence) {&#10;    return new ConfluenceClient(&#10;      ATLASSIAN_DOMAIN,&#10;      ATLASSIAN_USER,&#10;      ATLASSIAN_TOKEN&#10;    ) as any;&#10;  } else {&#10;    return new JiraClient(&#10;      ATLASSIAN_DOMAIN,&#10;      ATLASSIAN_USER,&#10;      ATLASSIAN_TOKEN&#10;    ) as any;&#10;  }&#10;}&#10;&#10;// Create FastMCP server&#10;const server = new FastMCP({&#10;  name: 'ConfluenceAssistant',&#10;  version: '1.0.0',&#10;  instructions: `This is a Confluence Assistant providing the following functions:&#10;  - Get page by ID&#10;  - Search pages by title&#10;  - Get all pages in a specific space&#10;  - Get child pages of a page&#10;  - Get all accessible spaces&#10;  - Get page history versions&#10;  - Get page comments&#10;  - Get page attachments&#10;  - Download specific attachments&#10;  - Get recently updated content&#10;  - Get content by label`,&#10;});&#10;&#10;// Error handling function&#10;const handleError = (error: any): never =&gt; {&#10;  if (error.response) {&#10;    const status = error.response.status;&#10;    const statusText = error.response.statusText;&#10;&#10;    if (status === 401) {&#10;      throw new UserError(&#10;        'Authentication Error: Failed to authenticate with Confluence. Please check your credentials.'&#10;      );&#10;    } else if (status === 403) {&#10;      throw new UserError(&#10;        'Permission Error: You do not have permission to access this resource in Confluence.'&#10;      );&#10;    } else if (status === 404) {&#10;      throw new UserError(&#10;        'Not Found Error: The requested Confluence resource could not be found. Please check the provided ID or parameters.'&#10;      );&#10;    } else {&#10;      throw new UserError(`Confluence API Error: ${status} ${statusText}`);&#10;    }&#10;  } else if (error instanceof UserError) {&#10;    // Pass through UserError instances&#10;    throw error;&#10;  } else {&#10;    throw new UserError(`An unexpected error occurred: ${error.message}`);&#10;  }&#10;};&#10;&#10;// Add MCP tool: Get Confluence page by ID&#10;server.addTool({&#10;  name: 'getPageById',&#10;  description: 'Get a Confluence page by its ID',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the Confluence page'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const page = await client.getPageById(args.pageId, ['body.storage']);&#10;&#10;      // Create a simplified page result with only the requested fields&#10;      const simpleResult: SimplePageResult = {&#10;        id: page.id,&#10;        status: page.status,&#10;        title: page.title,&#10;        content: page.body?.storage?.value || '',&#10;      };&#10;&#10;      return JSON.stringify(simpleResult, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Search pages by title&#10;server.addTool({&#10;  name: 'searchPagesByTitle',&#10;  description: 'Search for Confluence pages by title',&#10;  parameters: z.object({&#10;    title: z.string().describe('Page title or title fragment'),&#10;    spaceKey: z&#10;      .string()&#10;      .optional()&#10;      .describe('Optional space key to limit search scope'),&#10;    expand: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&quot;Fields to expand, e.g. ['body.storage']&quot;),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const pages = await client.getPagesByTitle(&#10;        args.title,&#10;        args.spaceKey,&#10;        args.expand || ['body.storage']&#10;      );&#10;      return JSON.stringify(pages, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get page comments&#10;server.addTool({&#10;  name: 'getPageComments',&#10;  description: 'Get comments on a Confluence page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the page'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 25'),&#10;    start: z&#10;      .number()&#10;      .optional()&#10;      .describe('Starting index for pagination, default is 0'),&#10;    expand: z.array(z.string()).optional().describe('Fields to expand'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const comments = await client.getPageComments(&#10;        args.pageId,&#10;        args.limit,&#10;        args.start,&#10;        args.expand || []&#10;      );&#10;      return JSON.stringify(comments, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get page attachments&#10;server.addTool({&#10;  name: 'getPageAttachments',&#10;  description: 'Get attachments on a Confluence page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the page'),&#10;    filename: z.string().optional().describe('Optional filename filter'),&#10;    mediaType: z.string().optional().describe('Optional media type filter'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 25'),&#10;    start: z&#10;      .number()&#10;      .optional()&#10;      .describe('Starting index for pagination, default is 0'),&#10;    expand: z.array(z.string()).optional().describe('Fields to expand'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const attachments = await client.getAttachments(&#10;        args.pageId,&#10;        args.filename,&#10;        args.mediaType,&#10;        args.limit,&#10;        args.start,&#10;        args.expand || []&#10;      );&#10;      return JSON.stringify(attachments, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get topically related pages&#10;server.addTool({&#10;  name: 'getRelatedPages',&#10;  description: 'Find pages that are topically related to a given page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the reference page'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 10'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const pagesResponse = await client.getTopicallyRelatedPages(&#10;        args.pageId,&#10;        args.limit || 10,&#10;        ['body.storage']&#10;      );&#10;&#10;      // Transform the results to SimplePageResult format&#10;      const simpleResults = pagesResponse.results.map(page =&gt; ({&#10;        id: page.id,&#10;        status: page.status,&#10;        title: page.title,&#10;        content: page.body?.storage?.value || '',&#10;      }));&#10;&#10;      // Return in the format expected by FastMCP&#10;      return JSON.stringify(&#10;        {&#10;          content: simpleResults,&#10;          totalCount: pagesResponse.size,&#10;          relatedToPageId: args.pageId,&#10;        },&#10;        null,&#10;        2&#10;      );&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get Jira issue by key&#10;server.addTool({&#10;  name: 'getJiraIssue',&#10;  description: 'Get a Jira issue by its key',&#10;  parameters: z.object({&#10;    issueKey: z&#10;      .string()&#10;      .describe('The key of the Jira issue (e.g., PROJECT-123)'),&#10;    fields: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe('Optional array of field names to include'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const issue = await jiraClient.getIssue(args.issueKey, args.fields);&#10;      // Only return extractedDetails (use type assertion to avoid TS error)&#10;      const extractedDetails = (issue as any).extractedDetails;&#10;      return typeof extractedDetails === 'string'&#10;        ? extractedDetails&#10;        : JSON.stringify(extractedDetails, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get all issues in a sprint, optionally filtered by a list of issue types&#10;server.addTool({&#10;  name: 'getSprintIssues',&#10;  description:&#10;    'Get all issues in a sprint, optionally filtered by a list of issue types',&#10;  parameters: z.object({&#10;    sprintId: z.number().describe('The ID of the sprint'),&#10;    startAt: z.number().optional().describe('Starting index for pagination'),&#10;    maxResults: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return'),&#10;    issueTypes: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&#10;        'Optional array of issue types to filter (e.g., [&quot;Story&quot;, &quot;Bug&quot;])'&#10;      ),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const issues = await jiraClient.getSprintIssues(&#10;        args.sprintId,&#10;        args.startAt || 0,&#10;        args.maxResults || 50,&#10;        args.issueTypes&#10;      );&#10;      return JSON.stringify(issues, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get related issues for a given issue&#10;server.addTool({&#10;  name: 'getRelatedIssues',&#10;  description: 'Find related issues for a given Jira issue',&#10;  parameters: z.object({&#10;    issueKey: z&#10;      .string()&#10;      .describe('The key of the Jira issue to find related issues for'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const related = await jiraClient.getRelatedIssues(args.issueKey);&#10;      return JSON.stringify(related, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get all issues in the active sprint for a board&#10;server.addTool({&#10;  name: 'getActiveSprintIssues',&#10;  description:&#10;    'Get all issues in the current active sprint for a given Jira board',&#10;  parameters: z.object({&#10;    boardId: z.number().describe('The ID of the Jira board'),&#10;    issueTypes: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&#10;        'Optional array of issue types to filter (e.g., [&quot;Story&quot;, &quot;Bug&quot;])'&#10;      ),&#10;    startAt: z.number().optional().describe('Starting index for pagination'),&#10;    maxResults: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      // Get the active sprint for the board&#10;      const sprintsResp = await jiraClient.getSprints(&#10;        args.boardId,&#10;        'active',&#10;        0,&#10;        1&#10;      );&#10;      const activeSprint =&#10;        sprintsResp.values &amp;&amp; sprintsResp.values.length &gt; 0&#10;          ? sprintsResp.values[0]&#10;          : null;&#10;      if (!activeSprint) {&#10;        return JSON.stringify(&#10;          { error: 'No active sprint found for this board.' },&#10;          null,&#10;          2&#10;        );&#10;      }&#10;      // Get issues in the active sprint&#10;      const issues = await jiraClient.getSprintIssues(&#10;        activeSprint.id,&#10;        args.startAt || 0,&#10;        args.maxResults || 50,&#10;        args.issueTypes&#10;      );&#10;      return JSON.stringify({ sprint: activeSprint, issues }, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;await server.start({&#10;  transportType: 'stdio',&#10;});&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env node&#10;&#10;import { FastMCP, UserError } from 'fastmcp';&#10;import { z } from 'zod';&#10;import { ConfluenceClient } from './confluence/ConfluenceClient.js';&#10;import { SimplePageResult } from './confluence/confluenceTypes.js';&#10;import { JiraClient } from './jira/JiraClient.js';&#10;import 'dotenv/config';&#10;&#10;// Initialize clients&#10;let client: ConfluenceClient;&#10;let jiraClient: JiraClient;&#10;&#10;export enum AtlassianServiceType {&#10;  Confluence = 'confluence',&#10;  Jira = 'jira',&#10;}&#10;&#10;function initAtlassianClient&lt;T extends AtlassianServiceType&gt;(&#10;  type: T&#10;): T extends AtlassianServiceType.Confluence ? ConfluenceClient : JiraClient {&#10;  const { ATLASSIAN_DOMAIN, ATLASSIAN_USER, ATLASSIAN_TOKEN } = process.env;&#10;  if (!ATLASSIAN_DOMAIN || !ATLASSIAN_USER || !ATLASSIAN_TOKEN) {&#10;    throw new UserError(&#10;      'Please set ATLASSIAN_DOMAIN, ATLASSIAN_USER, and ATLASSIAN_TOKEN in the .env file'&#10;    );&#10;  }&#10;  if (type === AtlassianServiceType.Confluence) {&#10;    return new ConfluenceClient(&#10;      ATLASSIAN_DOMAIN,&#10;      ATLASSIAN_USER,&#10;      ATLASSIAN_TOKEN&#10;    ) as any;&#10;  } else {&#10;    return new JiraClient(&#10;      ATLASSIAN_DOMAIN,&#10;      ATLASSIAN_USER,&#10;      ATLASSIAN_TOKEN&#10;    ) as any;&#10;  }&#10;}&#10;&#10;// Create FastMCP server&#10;const server = new FastMCP({&#10;  name: 'ConfluenceAssistant',&#10;  version: '1.0.0',&#10;  instructions: `This is a Confluence Assistant providing the following functions:&#10;  - Get page by ID&#10;  - Search pages by title&#10;  - Get all pages in a specific space&#10;  - Get child pages of a page&#10;  - Get all accessible spaces&#10;  - Get page history versions&#10;  - Get page comments&#10;  - Get page attachments&#10;  - Download specific attachments&#10;  - Get recently updated content&#10;  - Get content by label`,&#10;});&#10;&#10;// Error handling function&#10;const handleError = (error: any): never =&gt; {&#10;  if (error.response) {&#10;    const status = error.response.status;&#10;    const statusText = error.response.statusText;&#10;&#10;    if (status === 401) {&#10;      throw new UserError(&#10;        'Authentication Error: Failed to authenticate with Confluence. Please check your credentials.'&#10;      );&#10;    } else if (status === 403) {&#10;      throw new UserError(&#10;        'Permission Error: You do not have permission to access this resource in Confluence.'&#10;      );&#10;    } else if (status === 404) {&#10;      throw new UserError(&#10;        'Not Found Error: The requested Confluence resource could not be found. Please check the provided ID or parameters.'&#10;      );&#10;    } else {&#10;      throw new UserError(`Confluence API Error: ${status} ${statusText}`);&#10;    }&#10;  } else if (error instanceof UserError) {&#10;    // Pass through UserError instances&#10;    throw error;&#10;  } else {&#10;    throw new UserError(`An unexpected error occurred: ${error.message}`);&#10;  }&#10;};&#10;&#10;// Add MCP tool: Get Confluence page by ID&#10;server.addTool({&#10;  name: 'getPageById',&#10;  description: 'Get a Confluence page by its ID',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the Confluence page'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const page = await client.getPageById(args.pageId, ['body.storage']);&#10;&#10;      // Create a simplified page result with only the requested fields&#10;      const simpleResult: SimplePageResult = {&#10;        id: page.id,&#10;        status: page.status,&#10;        title: page.title,&#10;        content: page.body?.storage?.value || '',&#10;      };&#10;&#10;      return JSON.stringify(simpleResult, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Search pages by title&#10;server.addTool({&#10;  name: 'searchPagesByTitle',&#10;  description: 'Search for Confluence pages by title',&#10;  parameters: z.object({&#10;    title: z.string().describe('Page title or title fragment'),&#10;    spaceKey: z&#10;      .string()&#10;      .optional()&#10;      .describe('Optional space key to limit search scope'),&#10;    expand: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&quot;Fields to expand, e.g. ['body.storage']&quot;),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const pages = await client.getPagesByTitle(&#10;        args.title,&#10;        args.spaceKey,&#10;        args.expand || ['body.storage']&#10;      );&#10;      return JSON.stringify(pages, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get page comments&#10;server.addTool({&#10;  name: 'getPageComments',&#10;  description: 'Get comments on a Confluence page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the page'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 25'),&#10;    start: z&#10;      .number()&#10;      .optional()&#10;      .describe('Starting index for pagination, default is 0'),&#10;    expand: z.array(z.string()).optional().describe('Fields to expand'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const comments = await client.getPageComments(&#10;        args.pageId,&#10;        args.limit,&#10;        args.start,&#10;        args.expand || []&#10;      );&#10;      return JSON.stringify(comments, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get page attachments&#10;server.addTool({&#10;  name: 'getPageAttachments',&#10;  description: 'Get attachments on a Confluence page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the page'),&#10;    filename: z.string().optional().describe('Optional filename filter'),&#10;    mediaType: z.string().optional().describe('Optional media type filter'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 25'),&#10;    start: z&#10;      .number()&#10;      .optional()&#10;      .describe('Starting index for pagination, default is 0'),&#10;    expand: z.array(z.string()).optional().describe('Fields to expand'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const attachments = await client.getAttachments(&#10;        args.pageId,&#10;        args.filename,&#10;        args.mediaType,&#10;        args.limit,&#10;        args.start,&#10;        args.expand || []&#10;      );&#10;      return JSON.stringify(attachments, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get topically related pages&#10;server.addTool({&#10;  name: 'getRelatedPages',&#10;  description: 'Find pages that are topically related to a given page',&#10;  parameters: z.object({&#10;    pageId: z.string().describe('ID of the reference page'),&#10;    limit: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return, default is 10'),&#10;  }),&#10;  annotations: {&#10;    readOnlyHint: true,&#10;    openWorldHint: true,&#10;  },&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!client)&#10;        client = initAtlassianClient(AtlassianServiceType.Confluence);&#10;      const pagesResponse = await client.getTopicallyRelatedPages(&#10;        args.pageId,&#10;        args.limit || 10,&#10;        ['body.storage']&#10;      );&#10;&#10;      // Transform the results to SimplePageResult format&#10;      const simpleResults = pagesResponse.results.map(page =&gt; ({&#10;        id: page.id,&#10;        status: page.status,&#10;        title: page.title,&#10;        content: page.body?.storage?.value || '',&#10;      }));&#10;&#10;      // Return in the format expected by FastMCP&#10;      return JSON.stringify(&#10;        {&#10;          content: simpleResults,&#10;          totalCount: pagesResponse.size,&#10;          relatedToPageId: args.pageId,&#10;        },&#10;        null,&#10;        2&#10;      );&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get Jira issue by key&#10;server.addTool({&#10;  name: 'getJiraIssue',&#10;  description: 'Get a Jira issue by its key',&#10;  parameters: z.object({&#10;    issueKey: z&#10;      .string()&#10;      .describe('The key of the Jira issue (e.g., PROJECT-123)'),&#10;    fields: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe('Optional array of field names to include'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const issue = await jiraClient.getIssue(args.issueKey, args.fields);&#10;      // Only return extractedDetails (use type assertion to avoid TS error)&#10;      const extractedDetails = (issue as any).extractedDetails;&#10;      return typeof extractedDetails === 'string'&#10;        ? extractedDetails&#10;        : JSON.stringify(extractedDetails, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get all issues in a sprint, optionally filtered by a list of issue types&#10;server.addTool({&#10;  name: 'getSprintIssues',&#10;  description:&#10;    'Get all issues in a sprint, optionally filtered by a list of issue types',&#10;  parameters: z.object({&#10;    sprintId: z.number().describe('The ID of the sprint'),&#10;    startAt: z.number().optional().describe('Starting index for pagination'),&#10;    maxResults: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return'),&#10;    issueTypes: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&#10;        'Optional array of issue types to filter (e.g., [&quot;Story&quot;, &quot;Bug&quot;])'&#10;      ),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const issues = await jiraClient.getSprintIssues(&#10;        args.sprintId,&#10;        args.startAt || 0,&#10;        args.maxResults || 50,&#10;        args.issueTypes&#10;      );&#10;      return JSON.stringify(issues, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get related issues for a given issue&#10;server.addTool({&#10;  name: 'getRelatedIssues',&#10;  description: 'Find related issues for a given Jira issue',&#10;  parameters: z.object({&#10;    issueKey: z&#10;      .string()&#10;      .describe('The key of the Jira issue to find related issues for'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      const related = await jiraClient.getRelatedIssues(args.issueKey);&#10;      return JSON.stringify(related, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;// Add MCP tool: Get all issues in the active sprint for a board&#10;server.addTool({&#10;  name: 'getActiveSprintIssues',&#10;  description:&#10;    'Get all issues in the current active sprint for a given Jira board',&#10;  parameters: z.object({&#10;    boardId: z.number().describe('The ID of the Jira board'),&#10;    issueTypes: z&#10;      .array(z.string())&#10;      .optional()&#10;      .describe(&#10;        'Optional array of issue types to filter (e.g., [&quot;Story&quot;, &quot;Bug&quot;])'&#10;      ),&#10;    startAt: z.number().optional().describe('Starting index for pagination'),&#10;    maxResults: z&#10;      .number()&#10;      .optional()&#10;      .describe('Maximum number of results to return'),&#10;  }),&#10;  execute: async args =&gt; {&#10;    try {&#10;      if (!jiraClient)&#10;        jiraClient = initAtlassianClient(AtlassianServiceType.Jira);&#10;      // Get the active sprint for the board&#10;      const sprintsResp = await jiraClient.getSprints(&#10;        args.boardId,&#10;        'active',&#10;        0,&#10;        1&#10;      );&#10;      const activeSprint =&#10;        sprintsResp.values &amp;&amp; sprintsResp.values.length &gt; 0&#10;          ? sprintsResp.values[0]&#10;          : null;&#10;      if (!activeSprint) {&#10;        return JSON.stringify(&#10;          { error: 'No active sprint found for this board.' },&#10;          null,&#10;          2&#10;        );&#10;      }&#10;      // Use default issueTypes if not provided&#10;      const issueTypes = args.issueTypes &amp;&amp; args.issueTypes.length &gt; 0 ? args.issueTypes : [&quot;Story&quot;, &quot;Bug&quot;];&#10;      // Get issues in the active sprint&#10;      const issues = await jiraClient.getSprintIssues(&#10;        activeSprint.id,&#10;        args.startAt || 0,&#10;        args.maxResults || 50,&#10;        issueTypes&#10;      );&#10;      return JSON.stringify({ sprint: activeSprint, issues }, null, 2);&#10;    } catch (error) {&#10;      handleError(error);&#10;    }&#10;  },&#10;});&#10;&#10;await server.start({&#10;  transportType: 'stdio',&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/jira/JiraClient.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/jira/JiraClient.ts" />
              <option name="originalContent" value="import axios, { AxiosInstance } from 'axios';&#10;import {&#10;  JiraIssue,&#10;  JiraIssueListResponse,&#10;  JiraProject,&#10;  JiraProjectListResponse,&#10;  JiraBoard,&#10;  JiraBoardListResponse,&#10;  JiraSprint,&#10;  JiraSprintListResponse,&#10;  JiraUser,&#10;  JiraComment,&#10;  JiraCommentListResponse,&#10;  JiraWorklog,&#10;  JiraWorklogListResponse,&#10;  JiraSearchResponse,&#10;  JiraTransition,&#10;} from './jiraTypes.js';&#10;import { JiraIssueExtractor } from './JiraIssueExtractor.js';&#10;import https from 'https';&#10;&#10;export class JiraClient {&#10;  private readonly client: AxiosInstance;&#10;  private readonly issueExtractor: JiraIssueExtractor;&#10;&#10;  constructor(&#10;    private readonly domain: string,&#10;    private readonly user: string,&#10;    private readonly token: string&#10;  ) {&#10;    const authToken = Buffer.from(`${user}:${token}`).toString('base64');&#10;    this.client = axios.create({&#10;      baseURL: `https://${domain}/rest/api/3`,&#10;      headers: {&#10;        Authorization: `Basic ${authToken}`,&#10;        Accept: 'application/json',&#10;        'Content-Type': 'application/json',&#10;      },&#10;    });&#10;    this.issueExtractor = new JiraIssueExtractor();&#10;  }&#10;&#10;  /**&#10;   * Get a Jira issue by its key&#10;   * @param issueKey The key of the issue to retrieve (e.g., PROJECT-123)&#10;   * @param fields Optional array of field names to include&#10;   * @returns The issue data&#10;   */&#10;  async getIssue(issueKey: string, fields?: string[]): Promise&lt;JiraIssue&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {};&#10;      if (fields &amp;&amp; fields.length &gt; 0) {&#10;        params.fields = fields.join(',');&#10;      }&#10;      const config = {&#10;        httpsAgent: new https.Agent({ rejectUnauthorized: false }),&#10;      };&#10;      const response = await this.client.get(`/issue/${issueKey}`, {&#10;        params,&#10;        ...config,&#10;      });&#10;      const issue = response.data;&#10;      // Attach extracted details as a property for convenience&#10;      (issue as any).extractedDetails = this.extractIssueDetails(issue);&#10;      return issue;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for Jira issues using JQL (Jira Query Language)&#10;   * @param jql The JQL search query string&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @param fields Optional array of field names to include&#10;   * @returns Search results matching the query&#10;   * @example&#10;   * // Search for issues in the PROJECT project&#10;   * client.searchIssues('project = PROJECT')&#10;   * // Search for open bugs assigned to the current user&#10;   * client.searchIssues('type = Bug AND status = &quot;Open&quot; AND assignee = currentUser()')&#10;   */&#10;  async searchIssues(&#10;    jql: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50,&#10;    fields?: string[]&#10;  ): Promise&lt;JiraSearchResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        jql,&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (fields &amp;&amp; fields.length &gt; 0) {&#10;        params.fields = fields.join(',');&#10;      }&#10;&#10;      const response = await this.client.get('/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all projects the user has access to&#10;   * @param recent Get only recently accessed projects&#10;   * @returns List of projects&#10;   */&#10;  async getProjects(recent: boolean = false): Promise&lt;JiraProjectListResponse&gt; {&#10;    try {&#10;      const endpoint = recent ? '/project/recent' : '/project';&#10;      const response = await this.client.get(endpoint);&#10;      return { projects: response.data };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get a specific project by its key&#10;   * @param projectKey The key of the project to retrieve&#10;   * @returns The project data&#10;   */&#10;  async getProject(projectKey: string): Promise&lt;JiraProject&gt; {&#10;    try {&#10;      const response = await this.client.get(`/project/${projectKey}`);&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all boards visible to the user&#10;   * @param projectKeyOrId Optional project key to filter boards&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of boards&#10;   */&#10;  async getBoards(&#10;    projectKeyOrId?: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraBoardListResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (projectKeyOrId) {&#10;        params.projectKeyOrId = projectKeyOrId;&#10;      }&#10;&#10;      // Note: Boards use a different API endpoint&#10;      const response = await this.client.get('/board', {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all sprints in a board&#10;   * @param boardId The ID of the board&#10;   * @param state Optional filter for sprint state (future, active, closed)&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of sprints&#10;   */&#10;  async getSprints(&#10;    boardId: number,&#10;    state?: 'future' | 'active' | 'closed',&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraSprintListResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (state) {&#10;        params.state = state;&#10;      }&#10;&#10;      const response = await this.client.get(`/board/${boardId}/sprint`, {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all issues in a sprint, optionally filtered by a list of issue types&#10;   * @param sprintId The ID of the sprint&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @param issueTypes Optional array of issue types to filter (e.g., ['Story', 'Bug', 'Epic', 'Sub-task'])&#10;   * @returns List of issues (filtered if issueTypes is provided)&#10;   */&#10;  async getSprintIssues(&#10;    sprintId: number,&#10;    startAt: number = 0,&#10;    maxResults: number = 50,&#10;    issueTypes?: string[]&#10;  ): Promise&lt;JiraIssueListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/sprint/${sprintId}/issue`, {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      let issues = response.data.issues;&#10;      if (issueTypes &amp;&amp; Array.isArray(issueTypes) &amp;&amp; issueTypes.length &gt; 0) {&#10;        issues = issues.filter((issue: any) =&gt;&#10;          issueTypes.includes(issue.fields.issuetype?.name)&#10;        );&#10;      }&#10;      // Attach extracted details to each issue&#10;      issues = issues.map((issue: JiraIssue) =&gt; ({&#10;        ...issue,&#10;        extractedDetails: this.extractIssueDetails(issue),&#10;      }));&#10;      return { ...response.data, issues };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all users in the Jira instance&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of users&#10;   */&#10;  async getUsers(&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraUser[]&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/users/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for users by query string&#10;   * @param query The search query&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of matching users&#10;   */&#10;  async searchUsers(&#10;    query: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraUser[]&gt; {&#10;    try {&#10;      const params = {&#10;        query,&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/user/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get comments for an issue&#10;   * @param issueKey The key of the issue&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of comments&#10;   */&#10;  async getIssueComments(&#10;    issueKey: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraCommentListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/issue/${issueKey}/comment`, {&#10;        params,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all work logs for an issue&#10;   * @param issueKey The key of the issue&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of work logs&#10;   */&#10;  async getIssueWorklogs(&#10;    issueKey: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraWorklogListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/issue/${issueKey}/worklog`, {&#10;        params,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get issue types for a project&#10;   * @param projectIdOrKey The ID or key of the project&#10;   * @returns List of issue types&#10;   */&#10;  async getIssueTypes(projectIdOrKey: string): Promise&lt;any[]&gt; {&#10;    try {&#10;      const response = await this.client.get(&#10;        `/project/${projectIdOrKey}/statuses`&#10;      );&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get available transitions for an issue&#10;   * @param issueKey The key of the issue&#10;   * @returns List of available transitions&#10;   */&#10;  async getIssueTransitions(issueKey: string): Promise&lt;JiraTransition[]&gt; {&#10;    try {&#10;      const response = await this.client.get(`/issue/${issueKey}/transitions`);&#10;      return response.data.transitions;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Find related issues for a given issue&#10;   * @param issueKey The key of the issue to find related issues for&#10;   * @returns List of related issues&#10;   */&#10;  async getRelatedIssues(issueKey: string): Promise&lt;JiraIssue[]&gt; {&#10;    try {&#10;      // First get the issue to extract project, labels, etc.&#10;      const issue = await this.getIssue(issueKey, [&#10;        'summary',&#10;        'labels',&#10;        'project',&#10;      ]);&#10;&#10;      // Build a JQL query to find related issues&#10;      const relatedQueries = [];&#10;&#10;      // Issues in the same project&#10;      relatedQueries.push(`project = ${issue.fields.project.key}`);&#10;&#10;      // Issues with similar summary (extract keywords)&#10;      if (issue.fields.summary) {&#10;        const keywords = issue.fields.summary&#10;          .split(/\s+/)&#10;          .filter(word =&gt; word.length &gt; 3)&#10;          .map(word =&gt; word.replace(/[^\w\s]/g, ''));&#10;&#10;        if (keywords.length &gt; 0) {&#10;          const keywordQuery = keywords&#10;            .map(word =&gt; `summary ~ &quot;${word}&quot;`)&#10;            .join(' OR ');&#10;          relatedQueries.push(`(${keywordQuery})`);&#10;        }&#10;      }&#10;&#10;      // Issues with shared labels&#10;      if (issue.fields.labels &amp;&amp; issue.fields.labels.length &gt; 0) {&#10;        const labelQuery = issue.fields.labels&#10;          .map(label =&gt; `labels = &quot;${label}&quot;`)&#10;          .join(' OR ');&#10;        relatedQueries.push(`(${labelQuery})`);&#10;      }&#10;&#10;      // Combine queries and exclude the original issue&#10;      const jql = `(${relatedQueries.join(' OR ')}) AND issuekey != ${issueKey} ORDER BY updated DESC`;&#10;&#10;      // Execute search with the constructed JQL&#10;      const searchResult = await this.searchIssues(jql, 0, 10);&#10;      // Attach extracted details to each related issue&#10;      return searchResult.issues.map((issue: JiraIssue) =&gt; ({&#10;        ...issue,&#10;        extractedDetails: this.extractIssueDetails(issue),&#10;      }));&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all dashboards available to the user&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of dashboards&#10;   */&#10;  async getDashboards(&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;any&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/dashboard', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  private handleError(error: any): never {&#10;    if (error.response) {&#10;      console.error(&#10;        `Error: ${error.response.status} - ${error.response.statusText}`&#10;      );&#10;      if (error.response.status === 401) {&#10;        console.error(&#10;          'Authentication failed. Please check your email and API token.'&#10;        );&#10;      } else if (error.response.status === 403) {&#10;        console.error(&#10;          'Permission denied. You do not have access to this resource.'&#10;        );&#10;      } else if (error.response.status === 404) {&#10;        console.error(&#10;          'Resource not found. Please check the requested resource exists.'&#10;        );&#10;      }&#10;    } else {&#10;      console.error('An unexpected error occurred:', error.message);&#10;    }&#10;    throw error;&#10;  }&#10;&#10;  /**&#10;   * Extract formatted details from a Jira issue&#10;   * @param issue The Jira issue to extract details from&#10;   * @returns Formatted string with issue details&#10;   */&#10;  extractIssueDetails(issue: JiraIssue): string {&#10;    return this.issueExtractor.extractIssueDetails(issue);&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import axios, { AxiosInstance } from 'axios';&#10;import {&#10;  JiraIssue,&#10;  JiraIssueListResponse,&#10;  JiraProject,&#10;  JiraProjectListResponse,&#10;  JiraBoard,&#10;  JiraBoardListResponse,&#10;  JiraSprint,&#10;  JiraSprintListResponse,&#10;  JiraUser,&#10;  JiraComment,&#10;  JiraCommentListResponse,&#10;  JiraWorklog,&#10;  JiraWorklogListResponse,&#10;  JiraSearchResponse,&#10;  JiraTransition,&#10;} from './jiraTypes.js';&#10;import { JiraIssueExtractor } from './JiraIssueExtractor.js';&#10;import https from 'https';&#10;&#10;export class JiraClient {&#10;  private readonly client: AxiosInstance;&#10;  private readonly issueExtractor: JiraIssueExtractor;&#10;&#10;  constructor(&#10;    private readonly domain: string,&#10;    private readonly user: string,&#10;    private readonly token: string&#10;  ) {&#10;    const authToken = Buffer.from(`${user}:${token}`).toString('base64');&#10;    this.client = axios.create({&#10;      baseURL: `https://${domain}/rest/api/3`,&#10;      headers: {&#10;        Authorization: `Basic ${authToken}`,&#10;        Accept: 'application/json',&#10;        'Content-Type': 'application/json',&#10;      },&#10;    });&#10;    this.issueExtractor = new JiraIssueExtractor();&#10;  }&#10;&#10;  /**&#10;   * Get a Jira issue by its key&#10;   * @param issueKey The key of the issue to retrieve (e.g., PROJECT-123)&#10;   * @param fields Optional array of field names to include&#10;   * @returns The issue data&#10;   */&#10;  async getIssue(issueKey: string, fields?: string[]): Promise&lt;JiraIssue&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {};&#10;      if (fields &amp;&amp; fields.length &gt; 0) {&#10;        params.fields = fields.join(',');&#10;      }&#10;      const config = {&#10;        httpsAgent: new https.Agent({ rejectUnauthorized: false }),&#10;      };&#10;      const response = await this.client.get(`/issue/${issueKey}`, {&#10;        params,&#10;        ...config,&#10;      });&#10;      const issue = response.data;&#10;      // Attach extracted details as a property for convenience&#10;      (issue as any).extractedDetails = this.extractIssueDetails(issue);&#10;      return issue;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for Jira issues using JQL (Jira Query Language)&#10;   * @param jql The JQL search query string&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @param fields Optional array of field names to include&#10;   * @returns Search results matching the query&#10;   * @example&#10;   * // Search for issues in the PROJECT project&#10;   * client.searchIssues('project = PROJECT')&#10;   * // Search for open bugs assigned to the current user&#10;   * client.searchIssues('type = Bug AND status = &quot;Open&quot; AND assignee = currentUser()')&#10;   */&#10;  async searchIssues(&#10;    jql: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50,&#10;    fields?: string[]&#10;  ): Promise&lt;JiraSearchResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        jql,&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (fields &amp;&amp; fields.length &gt; 0) {&#10;        params.fields = fields.join(',');&#10;      }&#10;&#10;      const response = await this.client.get('/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all projects the user has access to&#10;   * @param recent Get only recently accessed projects&#10;   * @returns List of projects&#10;   */&#10;  async getProjects(recent: boolean = false): Promise&lt;JiraProjectListResponse&gt; {&#10;    try {&#10;      const endpoint = recent ? '/project/recent' : '/project';&#10;      const response = await this.client.get(endpoint);&#10;      return { projects: response.data };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get a specific project by its key&#10;   * @param projectKey The key of the project to retrieve&#10;   * @returns The project data&#10;   */&#10;  async getProject(projectKey: string): Promise&lt;JiraProject&gt; {&#10;    try {&#10;      const response = await this.client.get(`/project/${projectKey}`);&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all boards visible to the user&#10;   * @param projectKeyOrId Optional project key to filter boards&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of boards&#10;   */&#10;  async getBoards(&#10;    projectKeyOrId?: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraBoardListResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (projectKeyOrId) {&#10;        params.projectKeyOrId = projectKeyOrId;&#10;      }&#10;&#10;      // Note: Boards use a different API endpoint&#10;      const response = await this.client.get('/board', {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all sprints in a board&#10;   * @param boardId The ID of the board&#10;   * @param state Optional filter for sprint state (future, active, closed)&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of sprints&#10;   */&#10;  async getSprints(&#10;    boardId: number,&#10;    state?: 'future' | 'active' | 'closed',&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraSprintListResponse&gt; {&#10;    try {&#10;      const params: Record&lt;string, any&gt; = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      if (state) {&#10;        params.state = state;&#10;      }&#10;&#10;      const response = await this.client.get(`/board/${boardId}/sprint`, {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all issues in a sprint, optionally filtered by a list of issue types&#10;   * @param sprintId The ID of the sprint&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @param issueTypes Optional array of issue types to filter (e.g., ['Story', 'Bug', 'Epic', 'Sub-task'])&#10;   * @returns List of issues (filtered if issueTypes is provided)&#10;   */&#10;  async getSprintIssues(&#10;    sprintId: number,&#10;    startAt: number = 0,&#10;    maxResults: number = 50,&#10;    issueTypes?: string[]&#10;  ): Promise&lt;JiraIssueListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/sprint/${sprintId}/issue`, {&#10;        baseURL: `https://${this.domain}/rest/agile/1.0`,&#10;        params,&#10;      });&#10;&#10;      let issues = response.data.issues;&#10;      if (issueTypes &amp;&amp; Array.isArray(issueTypes) &amp;&amp; issueTypes.length &gt; 0) {&#10;        issues = issues.filter((issue: any) =&gt;&#10;          issueTypes.includes(issue.fields.issuetype?.name)&#10;        );&#10;      }&#10;      // Only return summary fields for each issue&#10;      issues = issues.map((issue: JiraIssue) =&gt;&#10;        this.issueExtractor.extractIssueSummary(issue)&#10;      );&#10;      return { ...response.data, issues };&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all users in the Jira instance&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of users&#10;   */&#10;  async getUsers(&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraUser[]&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/users/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Search for users by query string&#10;   * @param query The search query&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of matching users&#10;   */&#10;  async searchUsers(&#10;    query: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraUser[]&gt; {&#10;    try {&#10;      const params = {&#10;        query,&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/user/search', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get comments for an issue&#10;   * @param issueKey The key of the issue&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of comments&#10;   */&#10;  async getIssueComments(&#10;    issueKey: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraCommentListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/issue/${issueKey}/comment`, {&#10;        params,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all work logs for an issue&#10;   * @param issueKey The key of the issue&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of work logs&#10;   */&#10;  async getIssueWorklogs(&#10;    issueKey: string,&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;JiraWorklogListResponse&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get(`/issue/${issueKey}/worklog`, {&#10;        params,&#10;      });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get issue types for a project&#10;   * @param projectIdOrKey The ID or key of the project&#10;   * @returns List of issue types&#10;   */&#10;  async getIssueTypes(projectIdOrKey: string): Promise&lt;any[]&gt; {&#10;    try {&#10;      const response = await this.client.get(&#10;        `/project/${projectIdOrKey}/statuses`&#10;      );&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get available transitions for an issue&#10;   * @param issueKey The key of the issue&#10;   * @returns List of available transitions&#10;   */&#10;  async getIssueTransitions(issueKey: string): Promise&lt;JiraTransition[]&gt; {&#10;    try {&#10;      const response = await this.client.get(`/issue/${issueKey}/transitions`);&#10;      return response.data.transitions;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Find related issues for a given issue&#10;   * @param issueKey The key of the issue to find related issues for&#10;   * @returns List of related issues&#10;   */&#10;  async getRelatedIssues(issueKey: string): Promise&lt;any[]&gt; {&#10;    try {&#10;      // First get the issue to extract project, labels, etc.&#10;      const issue = await this.getIssue(issueKey, [&#10;        'summary',&#10;        'labels',&#10;        'project',&#10;      ]);&#10;&#10;      // Build a JQL query to find related issues&#10;      const relatedQueries = [];&#10;&#10;      // Issues in the same project&#10;      relatedQueries.push(`project = ${issue.fields.project.key}`);&#10;&#10;      // Issues with similar summary (extract keywords)&#10;      if (issue.fields.summary) {&#10;        const keywords = issue.fields.summary&#10;          .split(/\s+/)&#10;          .filter(word =&gt; word.length &gt; 3)&#10;          .map(word =&gt; word.replace(/[^\w\s]/g, ''));&#10;&#10;        if (keywords.length &gt; 0) {&#10;          const keywordQuery = keywords&#10;            .map(word =&gt; `summary ~ &quot;${word}&quot;`)&#10;            .join(' OR ');&#10;          relatedQueries.push(`(${keywordQuery})`);&#10;        }&#10;      }&#10;&#10;      // Issues with shared labels&#10;      if (issue.fields.labels &amp;&amp; issue.fields.labels.length &gt; 0) {&#10;        const labelQuery = issue.fields.labels&#10;          .map(label =&gt; `labels = &quot;${label}&quot;`)&#10;          .join(' OR ');&#10;        relatedQueries.push(`(${labelQuery})`);&#10;      }&#10;&#10;      // Combine queries and exclude the original issue&#10;      const jql = `(${relatedQueries.join(' OR ')}) AND issuekey != ${issueKey} ORDER BY updated DESC`;&#10;&#10;      // Execute search with the constructed JQL&#10;      const searchResult = await this.searchIssues(jql, 0, 10);&#10;      // Only return summary fields for each related issue&#10;      return searchResult.issues.map((issue: JiraIssue) =&gt;&#10;        this.issueExtractor.extractIssueSummary(issue)&#10;      );&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get all dashboards available to the user&#10;   * @param startAt Starting index for pagination&#10;   * @param maxResults Maximum number of results to return&#10;   * @returns List of dashboards&#10;   */&#10;  async getDashboards(&#10;    startAt: number = 0,&#10;    maxResults: number = 50&#10;  ): Promise&lt;any&gt; {&#10;    try {&#10;      const params = {&#10;        startAt,&#10;        maxResults,&#10;      };&#10;&#10;      const response = await this.client.get('/dashboard', { params });&#10;      return response.data;&#10;    } catch (error) {&#10;      this.handleError(error);&#10;    }&#10;  }&#10;&#10;  private handleError(error: any): never {&#10;    if (error.response) {&#10;      console.error(&#10;        `Error: ${error.response.status} - ${error.response.statusText}`&#10;      );&#10;      if (error.response.status === 401) {&#10;        console.error(&#10;          'Authentication failed. Please check your email and API token.'&#10;        );&#10;      } else if (error.response.status === 403) {&#10;        console.error(&#10;          'Permission denied. You do not have access to this resource.'&#10;        );&#10;      } else if (error.response.status === 404) {&#10;        console.error(&#10;          'Resource not found. Please check the requested resource exists.'&#10;        );&#10;      }&#10;    } else {&#10;      console.error('An unexpected error occurred:', error.message);&#10;    }&#10;    throw error;&#10;  }&#10;&#10;  /**&#10;   * Extract formatted details from a Jira issue&#10;   * @param issue The Jira issue to extract details from&#10;   * @returns Formatted string with issue details&#10;   */&#10;  extractIssueDetails(issue: JiraIssue): string {&#10;    return this.issueExtractor.extractIssueDetails(issue);&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/jira/JiraIssueExtractor.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/jira/JiraIssueExtractor.ts" />
              <option name="originalContent" value="import { JiraIssue } from './jiraTypes.js';&#10;&#10;/**&#10; * Class to extract and format data from Jira issues&#10; * Handles parsing of Atlassian Document Format (ADF) content and other Jira structures&#10; */&#10;export class JiraIssueExtractor {&#10;  /**&#10;   * Extract formatted details from a Jira issue&#10;   * @param issue The Jira issue to extract details from&#10;   * @returns Formatted string with key issue details&#10;   */&#10;  extractIssueDetails(issue: JiraIssue): string {&#10;    if (!issue || !issue.fields) {&#10;      return 'No issue data available';&#10;    }&#10;&#10;    const { key, fields } = issue;&#10;    const { summary, status, issuetype, assignee, reporter } = fields;&#10;&#10;    // Start building result with basic issue details&#10;    const result = [&#10;      `Issue Key: ${key}`,&#10;      `Summary: ${summary || 'No summary'}`,&#10;      `Status: ${status?.name || 'Unknown'}`,&#10;      `Type: ${issuetype?.name || 'Unknown'}`,&#10;      `Assignee: ${assignee?.displayName || 'Unassigned'}`,&#10;      `Reporter: ${reporter?.displayName || 'Unknown'}`,&#10;    ];&#10;&#10;    // Extract description content if available&#10;    if (fields.description) {&#10;      result.push('', 'Description:');&#10;      const descriptionText = this.extractADFContent(fields.description);&#10;      result.push(descriptionText);&#10;    }&#10;&#10;    // Look for common custom fields and add them if present&#10;    const customFields = Object.keys(fields).filter(field =&gt;&#10;      field.startsWith('customfield_')&#10;    );&#10;    if (customFields.length &gt; 0) {&#10;      result.push('', 'Custom Fields:');&#10;&#10;      customFields.forEach(fieldKey =&gt; {&#10;        const fieldValue = fields[fieldKey];&#10;        // Skip null/undefined fields&#10;        if (fieldValue === null || fieldValue === undefined) return;&#10;&#10;        // If it's an ADF content&#10;        if (&#10;          fieldValue &amp;&amp;&#10;          typeof fieldValue === 'object' &amp;&amp;&#10;          fieldValue.content&#10;        ) {&#10;          const extractedText = this.extractADFContent(fieldValue);&#10;          if (extractedText.trim()) {&#10;            result.push(`${fieldKey}:`);&#10;            result.push(extractedText);&#10;          }&#10;        }&#10;        // For array values like labels, components, etc.&#10;        else if (Array.isArray(fieldValue)) {&#10;          if (fieldValue.length &gt; 0) {&#10;            const values = fieldValue&#10;              .map(item =&gt; {&#10;                if (typeof item === 'string') return item;&#10;                if (item &amp;&amp; item.name) return item.name;&#10;                if (item &amp;&amp; item.value) return item.value;&#10;                return JSON.stringify(item);&#10;              })&#10;              .filter(Boolean)&#10;              .join(', ');&#10;&#10;            if (values) {&#10;              result.push(`${fieldKey}: ${values}`);&#10;            }&#10;          }&#10;        }&#10;        // For object values that have a name/value/displayName property&#10;        else if (typeof fieldValue === 'object') {&#10;          const value =&#10;            fieldValue.name || fieldValue.value || fieldValue.displayName;&#10;          if (value) {&#10;            result.push(`${fieldKey}: ${value}`);&#10;          }&#10;        }&#10;        // For simple values&#10;        else if (typeof fieldValue !== 'object') {&#10;          result.push(`${fieldKey}: ${fieldValue}`);&#10;        }&#10;      });&#10;    }&#10;&#10;    return result.join('\n');&#10;  }&#10;&#10;  /**&#10;   * Extract a summary object with key fields from a Jira issue&#10;   * @param issue The Jira issue to extract summary from&#10;   * @returns Object with only key fields&#10;   */&#10;  extractIssueSummary(issue: JiraIssue): Record&lt;string, string&gt; {&#10;    if (!issue || !issue.fields) {&#10;      return {};&#10;    }&#10;    const { key, fields } = issue;&#10;    return {&#10;      IssueKey: key,&#10;      Summary: fields.summary || '',&#10;      Status: fields.status?.name || '',&#10;      Type: fields.issuetype?.name || '',&#10;      Assignee: fields.assignee?.displayName || '',&#10;      Reporter: fields.reporter?.displayName || '',&#10;      Points: fields.customfield_10318 || '', // 10318 custom field for story points&#10;    };&#10;  }&#10;&#10;  /**&#10;   * Extract plain text from Atlassian Document Format (ADF) content&#10;   * Handles various content types: paragraphs, panels, lists, code blocks, etc.&#10;   * @param adf The ADF content object&#10;   * @returns Extracted plain text&#10;   */&#10;  extractADFContent(adf: any): string {&#10;    if (!adf || !adf.content || !Array.isArray(adf.content)) {&#10;      return '';&#10;    }&#10;&#10;    const result: string[] = [];&#10;&#10;    // Process each top-level content node&#10;    adf.content.forEach(node =&gt; {&#10;      if (!node) return;&#10;&#10;      switch (node.type) {&#10;        case 'paragraph': {&#10;          const paragraphText = this.extractTextFromNode(node);&#10;          if (paragraphText) result.push(paragraphText);&#10;          break;&#10;        }&#10;&#10;        case 'heading': {&#10;          const headingText = this.extractTextFromNode(node);&#10;          if (headingText) {&#10;            const level = node.attrs?.level || 1;&#10;            const prefix = '#'.repeat(level) + ' ';&#10;            result.push(`${prefix}${headingText}`);&#10;          }&#10;          break;&#10;        }&#10;        case 'bulletList':&#10;        case 'orderedList': {&#10;          const listText = this.extractListContent(node);&#10;          if (listText) result.push(listText);&#10;          break;&#10;        }&#10;&#10;        case 'panel': {&#10;          const panelTitle = node.attrs?.panelType&#10;            ? `[${node.attrs.panelType}] `&#10;            : '';&#10;          const panelContent = this.extractTextFromNode(node);&#10;          if (panelContent) result.push(`${panelTitle}${panelContent}`);&#10;          break;&#10;        }&#10;&#10;        case 'codeBlock': {&#10;          const language = node.attrs?.language&#10;            ? `[${node.attrs.language}]\n`&#10;            : '';&#10;          const codeContent = this.extractTextFromNode(node);&#10;          if (codeContent) {&#10;            result.push(`${language}\`\`\`\n${codeContent}\n\`\`\``);&#10;          }&#10;          break;&#10;        }&#10;        case 'table': {&#10;          const tableContent = this.extractTableContent(node);&#10;          if (tableContent) result.push(tableContent);&#10;          break;&#10;        }&#10;&#10;        case 'blockquote': {&#10;          const quoteContent = this.extractTextFromNode(node);&#10;          if (quoteContent) {&#10;            result.push(`&gt; ${quoteContent.replace(/\n/g, '\n&gt; ')}`);&#10;          }&#10;          break;&#10;        }&#10;        case 'mediaGroup':&#10;          if (node.content &amp;&amp; Array.isArray(node.content)) {&#10;            node.content.forEach(media =&gt; {&#10;              if (media.type === 'media' &amp;&amp; media.attrs) {&#10;                const fileName = media.attrs.filename || 'Attached file';&#10;                result.push(`[${fileName}]`);&#10;              }&#10;            });&#10;          }&#10;          break;&#10;&#10;        // For any other node types, try to extract text if it has content&#10;        default:&#10;          if (node.content &amp;&amp; Array.isArray(node.content)) {&#10;            const defaultText = this.extractTextFromNode(node);&#10;            if (defaultText) result.push(defaultText);&#10;          }&#10;          break;&#10;      }&#10;    });&#10;&#10;    return result.join('\n\n');&#10;  }&#10;&#10;  /**&#10;   * Extract text from a node with content array&#10;   * @param node Node with potential content array&#10;   * @returns Extracted text&#10;   */&#10;  private extractTextFromNode(node: any): string {&#10;    if (!node || !node.content || !Array.isArray(node.content)) {&#10;      return '';&#10;    }&#10;&#10;    return node.content&#10;      .map(childNode =&gt; {&#10;        if (childNode.type === 'text' &amp;&amp; childNode.text) {&#10;          let text = childNode.text;&#10;&#10;          // Apply text formatting if available&#10;          if (childNode.marks &amp;&amp; Array.isArray(childNode.marks)) {&#10;            childNode.marks.forEach((mark: any) =&gt; {&#10;              if (mark.type === 'strong') text = `**${text}**`;&#10;              if (mark.type === 'em') text = `*${text}*`;&#10;              if (mark.type === 'code') text = `\`${text}\``;&#10;              if (mark.type === 'link' &amp;&amp; mark.attrs &amp;&amp; mark.attrs.href) {&#10;                text = `[${text}](${mark.attrs.href})`;&#10;              }&#10;            });&#10;          }&#10;&#10;          return text;&#10;        } else if (childNode.content &amp;&amp; Array.isArray(childNode.content)) {&#10;          // Recursively extract text from nested content&#10;          return this.extractTextFromNode(childNode);&#10;        }&#10;        return '';&#10;      })&#10;      .filter(Boolean)&#10;      .join(' ');&#10;  }&#10;&#10;  /**&#10;   * Extract content from lists (bullet or ordered)&#10;   * @param listNode List node with items&#10;   * @returns Formatted list text&#10;   */&#10;  private extractListContent(listNode: any): string {&#10;    if (!listNode || !listNode.content || !Array.isArray(listNode.content)) {&#10;      return '';&#10;    }&#10;&#10;    const result: string[] = [];&#10;    const isOrdered = listNode.type === 'orderedList';&#10;&#10;    listNode.content.forEach((listItem: any, index: number) =&gt; {&#10;      if (listItem.type === 'listItem' &amp;&amp; listItem.content) {&#10;        const itemContent = this.extractTextFromNode(listItem);&#10;        if (itemContent) {&#10;          const prefix = isOrdered ? `${index + 1}. ` : '• ';&#10;          result.push(`${prefix}${itemContent}`);&#10;        }&#10;      }&#10;    });&#10;&#10;    return result.join('\n');&#10;  }&#10;&#10;  /**&#10;   * Extract content from table nodes&#10;   * @param tableNode Table node&#10;   * @returns Formatted table text&#10;   */&#10;  private extractTableContent(tableNode: any): string {&#10;    if (!tableNode || !tableNode.content || !Array.isArray(tableNode.content)) {&#10;      return '';&#10;    }&#10;&#10;    const rows: string[][] = [];&#10;&#10;    // Process table rows&#10;    tableNode.content.forEach((row: any) =&gt; {&#10;      if (&#10;        row.type === 'tableRow' &amp;&amp;&#10;        row.content &amp;&amp;&#10;        Array.isArray(row.content)&#10;      ) {&#10;        const cells: string[] = [];&#10;&#10;        // Process cells in the row&#10;        row.content.forEach((cell: any) =&gt; {&#10;          if (&#10;            (cell.type === 'tableCell' || cell.type === 'tableHeader') &amp;&amp;&#10;            cell.content &amp;&amp;&#10;            Array.isArray(cell.content)&#10;          ) {&#10;            const cellContent = this.extractTextFromNode(cell);&#10;            cells.push(cellContent || '');&#10;          }&#10;        });&#10;&#10;        if (cells.length &gt; 0) {&#10;          rows.push(cells);&#10;        }&#10;      }&#10;    });&#10;&#10;    // If no valid rows, return empty string&#10;    if (rows.length === 0) {&#10;      return '';&#10;    }&#10;&#10;    // Format as a simplified table&#10;    const result: string[] = [];&#10;    rows.forEach((row, index) =&gt; {&#10;      result.push(`| ${row.join(' | ')} |`);&#10;&#10;      // Add separator after header row&#10;      if (index === 0) {&#10;        result.push(`| ${row.map(() =&gt; '---').join(' | ')} |`);&#10;      }&#10;    });&#10;&#10;    return result.join('\n');&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { JiraIssue } from './jiraTypes.js';&#10;&#10;/**&#10; * Class to extract and format data from Jira issues&#10; * Handles parsing of Atlassian Document Format (ADF) content and other Jira structures&#10; */&#10;export class JiraIssueExtractor {&#10;  /**&#10;   * Extract formatted details from a Jira issue&#10;   * @param issue The Jira issue to extract details from&#10;   * @returns Formatted string with key issue details&#10;   */&#10;  extractIssueDetails(issue: JiraIssue): string {&#10;    if (!issue || !issue.fields) {&#10;      return 'No issue data available';&#10;    }&#10;&#10;    const { key, fields } = issue;&#10;    const { summary, status, issuetype, assignee, reporter } = fields;&#10;&#10;    // Start building result with basic issue details&#10;    const result = [&#10;      `Issue Key: ${key}`,&#10;      `Summary: ${summary || 'No summary'}`,&#10;      `Status: ${status?.name || 'Unknown'}`,&#10;      `Type: ${issuetype?.name || 'Unknown'}`,&#10;      `Assignee: ${assignee?.displayName || 'Unassigned'}`,&#10;      `Reporter: ${reporter?.displayName || 'Unknown'}`,&#10;    ];&#10;&#10;    // Extract description content if available&#10;    if (fields.description) {&#10;      result.push('', 'Description:');&#10;      const descriptionText = this.extractADFContent(fields.description);&#10;      result.push(descriptionText);&#10;    }&#10;&#10;    // Look for common custom fields and add them if present&#10;    const customFields = Object.keys(fields).filter(field =&gt;&#10;      field.startsWith('customfield_')&#10;    );&#10;    if (customFields.length &gt; 0) {&#10;      result.push('', 'Custom Fields:');&#10;&#10;      customFields.forEach(fieldKey =&gt; {&#10;        const fieldValue = fields[fieldKey];&#10;        // Skip null/undefined fields&#10;        if (fieldValue === null || fieldValue === undefined) return;&#10;&#10;        // If it's an ADF content&#10;        if (&#10;          fieldValue &amp;&amp;&#10;          typeof fieldValue === 'object' &amp;&amp;&#10;          fieldValue.content&#10;        ) {&#10;          const extractedText = this.extractADFContent(fieldValue);&#10;          if (extractedText.trim()) {&#10;            result.push(`${fieldKey}:`);&#10;            result.push(extractedText);&#10;          }&#10;        }&#10;        // For array values like labels, components, etc.&#10;        else if (Array.isArray(fieldValue)) {&#10;          if (fieldValue.length &gt; 0) {&#10;            const values = fieldValue&#10;              .map(item =&gt; {&#10;                if (typeof item === 'string') return item;&#10;                if (item &amp;&amp; item.name) return item.name;&#10;                if (item &amp;&amp; item.value) return item.value;&#10;                return JSON.stringify(item);&#10;              })&#10;              .filter(Boolean)&#10;              .join(', ');&#10;&#10;            if (values) {&#10;              result.push(`${fieldKey}: ${values}`);&#10;            }&#10;          }&#10;        }&#10;        // For object values that have a name/value/displayName property&#10;        else if (typeof fieldValue === 'object') {&#10;          const value =&#10;            fieldValue.name || fieldValue.value || fieldValue.displayName;&#10;          if (value) {&#10;            result.push(`${fieldKey}: ${value}`);&#10;          }&#10;        }&#10;        // For simple values&#10;        else if (typeof fieldValue !== 'object') {&#10;          result.push(`${fieldKey}: ${fieldValue}`);&#10;        }&#10;      });&#10;    }&#10;&#10;    return result.join('\n');&#10;  }&#10;&#10;  /**&#10;   * Extract a summary object with key fields from a Jira issue&#10;   * @param issue The Jira issue to extract summary from&#10;   * @returns Object with only key fields&#10;   */&#10;  extractIssueSummary(issue: JiraIssue): Record&lt;string, string&gt; {&#10;    if (!issue || !issue.fields) {&#10;      return {};&#10;    }&#10;    const { key, fields } = issue;&#10;    return {&#10;      IssueKey: key,&#10;      Summary: fields.summary || '',&#10;      Status: fields.status?.name || '',&#10;      Type: fields.issuetype?.name || '',&#10;      Assignee: fields.assignee?.displayName || '',&#10;      Reporter: fields.reporter?.displayName || '',&#10;      Points: fields.customfield_10318 || '', // Example custom field for story points&#10;      Priority: fields.priority?.name || '',&#10;    };&#10;  }&#10;&#10;  /**&#10;   * Extract plain text from Atlassian Document Format (ADF) content&#10;   * Handles various content types: paragraphs, panels, lists, code blocks, etc.&#10;   * @param adf The ADF content object&#10;   * @returns Extracted plain text&#10;   */&#10;  extractADFContent(adf: any): string {&#10;    if (!adf || !adf.content || !Array.isArray(adf.content)) {&#10;      return '';&#10;    }&#10;&#10;    const result: string[] = [];&#10;&#10;    // Process each top-level content node&#10;    adf.content.forEach(node =&gt; {&#10;      if (!node) return;&#10;&#10;      switch (node.type) {&#10;        case 'paragraph': {&#10;          const paragraphText = this.extractTextFromNode(node);&#10;          if (paragraphText) result.push(paragraphText);&#10;          break;&#10;        }&#10;&#10;        case 'heading': {&#10;          const headingText = this.extractTextFromNode(node);&#10;          if (headingText) {&#10;            const level = node.attrs?.level || 1;&#10;            const prefix = '#'.repeat(level) + ' ';&#10;            result.push(`${prefix}${headingText}`);&#10;          }&#10;          break;&#10;        }&#10;        case 'bulletList':&#10;        case 'orderedList': {&#10;          const listText = this.extractListContent(node);&#10;          if (listText) result.push(listText);&#10;          break;&#10;        }&#10;&#10;        case 'panel': {&#10;          const panelTitle = node.attrs?.panelType&#10;            ? `[${node.attrs.panelType}] `&#10;            : '';&#10;          const panelContent = this.extractTextFromNode(node);&#10;          if (panelContent) result.push(`${panelTitle}${panelContent}`);&#10;          break;&#10;        }&#10;&#10;        case 'codeBlock': {&#10;          const language = node.attrs?.language&#10;            ? `[${node.attrs.language}]\n`&#10;            : '';&#10;          const codeContent = this.extractTextFromNode(node);&#10;          if (codeContent) {&#10;            result.push(`${language}\`\`\`\n${codeContent}\n\`\`\``);&#10;          }&#10;          break;&#10;        }&#10;        case 'table': {&#10;          const tableContent = this.extractTableContent(node);&#10;          if (tableContent) result.push(tableContent);&#10;          break;&#10;        }&#10;&#10;        case 'blockquote': {&#10;          const quoteContent = this.extractTextFromNode(node);&#10;          if (quoteContent) {&#10;            result.push(`&gt; ${quoteContent.replace(/\n/g, '\n&gt; ')}`);&#10;          }&#10;          break;&#10;        }&#10;        case 'mediaGroup':&#10;          if (node.content &amp;&amp; Array.isArray(node.content)) {&#10;            node.content.forEach(media =&gt; {&#10;              if (media.type === 'media' &amp;&amp; media.attrs) {&#10;                const fileName = media.attrs.filename || 'Attached file';&#10;                result.push(`[${fileName}]`);&#10;              }&#10;            });&#10;          }&#10;          break;&#10;&#10;        // For any other node types, try to extract text if it has content&#10;        default:&#10;          if (node.content &amp;&amp; Array.isArray(node.content)) {&#10;            const defaultText = this.extractTextFromNode(node);&#10;            if (defaultText) result.push(defaultText);&#10;          }&#10;          break;&#10;      }&#10;    });&#10;&#10;    return result.join('\n\n');&#10;  }&#10;&#10;  /**&#10;   * Extract text from a node with content array&#10;   * @param node Node with potential content array&#10;   * @returns Extracted text&#10;   */&#10;  private extractTextFromNode(node: any): string {&#10;    if (!node || !node.content || !Array.isArray(node.content)) {&#10;      return '';&#10;    }&#10;&#10;    return node.content&#10;      .map(childNode =&gt; {&#10;        if (childNode.type === 'text' &amp;&amp; childNode.text) {&#10;          let text = childNode.text;&#10;&#10;          // Apply text formatting if available&#10;          if (childNode.marks &amp;&amp; Array.isArray(childNode.marks)) {&#10;            childNode.marks.forEach((mark: any) =&gt; {&#10;              if (mark.type === 'strong') text = `**${text}**`;&#10;              if (mark.type === 'em') text = `*${text}*`;&#10;              if (mark.type === 'code') text = `\`${text}\``;&#10;              if (mark.type === 'link' &amp;&amp; mark.attrs &amp;&amp; mark.attrs.href) {&#10;                text = `[${text}](${mark.attrs.href})`;&#10;              }&#10;            });&#10;          }&#10;&#10;          return text;&#10;        } else if (childNode.content &amp;&amp; Array.isArray(childNode.content)) {&#10;          // Recursively extract text from nested content&#10;          return this.extractTextFromNode(childNode);&#10;        }&#10;        return '';&#10;      })&#10;      .filter(Boolean)&#10;      .join(' ');&#10;  }&#10;&#10;  /**&#10;   * Extract content from lists (bullet or ordered)&#10;   * @param listNode List node with items&#10;   * @returns Formatted list text&#10;   */&#10;  private extractListContent(listNode: any): string {&#10;    if (!listNode || !listNode.content || !Array.isArray(listNode.content)) {&#10;      return '';&#10;    }&#10;&#10;    const result: string[] = [];&#10;    const isOrdered = listNode.type === 'orderedList';&#10;&#10;    listNode.content.forEach((listItem: any, index: number) =&gt; {&#10;      if (listItem.type === 'listItem' &amp;&amp; listItem.content) {&#10;        const itemContent = this.extractTextFromNode(listItem);&#10;        if (itemContent) {&#10;          const prefix = isOrdered ? `${index + 1}. ` : '• ';&#10;          result.push(`${prefix}${itemContent}`);&#10;        }&#10;      }&#10;    });&#10;&#10;    return result.join('\n');&#10;  }&#10;&#10;  /**&#10;   * Extract content from table nodes&#10;   * @param tableNode Table node&#10;   * @returns Formatted table text&#10;   */&#10;  private extractTableContent(tableNode: any): string {&#10;    if (!tableNode || !tableNode.content || !Array.isArray(tableNode.content)) {&#10;      return '';&#10;    }&#10;&#10;    const rows: string[][] = [];&#10;&#10;    // Process table rows&#10;    tableNode.content.forEach((row: any) =&gt; {&#10;      if (&#10;        row.type === 'tableRow' &amp;&amp;&#10;        row.content &amp;&amp;&#10;        Array.isArray(row.content)&#10;      ) {&#10;        const cells: string[] = [];&#10;&#10;        // Process cells in the row&#10;        row.content.forEach((cell: any) =&gt; {&#10;          if (&#10;            (cell.type === 'tableCell' || cell.type === 'tableHeader') &amp;&amp;&#10;            cell.content &amp;&amp;&#10;            Array.isArray(cell.content)&#10;          ) {&#10;            const cellContent = this.extractTextFromNode(cell);&#10;            cells.push(cellContent || '');&#10;          }&#10;        });&#10;&#10;        if (cells.length &gt; 0) {&#10;          rows.push(cells);&#10;        }&#10;      }&#10;    });&#10;&#10;    // If no valid rows, return empty string&#10;    if (rows.length === 0) {&#10;      return '';&#10;    }&#10;&#10;    // Format as a simplified table&#10;    const result: string[] = [];&#10;    rows.forEach((row, index) =&gt; {&#10;      result.push(`| ${row.join(' | ')} |`);&#10;&#10;      // Add separator after header row&#10;      if (index === 0) {&#10;        result.push(`| ${row.map(() =&gt; '---').join(' | ')} |`);&#10;      }&#10;    });&#10;&#10;    return result.join('\n');&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>